.. highlight:: cpp

2-SAT
=====

.. important::
 
    Если по каким-то причинам до текущего момента вы ещё не успели ознакомиться с алгоритмом поиска компонент сильной связности, настоятельно рекомендуется сделать это перед прочтением этой статьи.

`2-SAT` (2-satisfiability) - алгоритм для конструктивного распределения значений булевым переменным, для выполнения некоторых условий. Для быстрого понимания сути алгоритма, приведу пример задачи на него:

Есть неориентированный граф, где у каждой вершины есть вес. Нужно прибавить единичку к некоторым вершинам, чтобы в итоге не было двух вершин одно веса, соединённых ребром.

То есть более формально: есть связи между булевыми величинами. Нужно восстановить их значения или сказать что это невозможно:

`f = (x1 ^ y1) & (x2 ^ y2) &... &(xn ^ yn)`


Если вернуться к задаче, то события будут "прибавилась единичка к вершинке `i`" и "не прибавилась единичка к вершинке `i`", а соотношения между вершинками лекго перевести на `xor`.

Алгоритм
________

Представим (a xor b) как (!a => b and !b => a). Тогда если сделать граф, где каждая вершина будет являтся возможным значением каждой переменной (то есть вершины а и !а), тогда все взаимосвязи можно будет описать как ориентированые рёбра в этом графе. На самом деле нас не устраивает только конструкция при которой из а следует !а, то есть когда есть рёберный путь между соответствующими вершинами. Значит если мы сделаем конденсацию графа, они не должны быть в одной компоненте сильной связности, так как иначе выбрать значение для переменной невозможно. Если таких противоречий нет, сделаем топологическую сортировку графа, та из вершин а и !а, которая окажется самой правой (при условии что рёбра в топологической сортировке между разными компонентами идут слева направо), и есть нужное значение.

Код

::

	vector<vector<long long>> graph, reversed_graph;
	vector<bool> used;
	vector<long long> topsort, comp, answer;

	void dfs(long long v) {
		used[v] = true;
		for (long long to : graph[v]) {
			if (!used[to]) {
				dfs(to);
			}
		}
		topsort.push_back(v);
	}

	void dfs2(long long v, long long &color) {
		comp[v] = color;
		for (long long to : reversed_graph[v]) {
			if (comp[to] == -1) {
				dfs2(to, color);
			}
		}
	}

	signed main() {
		// input data
		bool solution = true;
		used.assign(n * 2, false);
		for (long long i = 0; i < n * 2; i++) {
			if (!used[i]) {
				dfs(i);
			}
		}
		ll comp_number = 0;
		comp.assign(n * 2, -1);
		for (long long i = n * 2 - 1; i > -1; i--) {
			if (comp[topp[i]]] == -1) {
				dfs2(i, comp_number);
				comp_number++;
			}
		}
		for (long long i = 0; i < n; i++) {
			if (comp[i] != comp[i + n]) {
				ans = {-1};
				return 0;
			}
		}
		ans = {};
		for (long long i = 0; i < n; i++) {
			if (comp[i] > comp[i + n]) {
				ans.push_back(i);
			} else {
				ans.push_back(i + n);
			}
		}
		// output data
	}

Применения 2-SAT
________________

Есть несколько интересных идей, отражённых в следующих задачах, которые кажутся полезными. Зачастую в задачах на 2-sat важно правильно определить что именно является вершинами нужного графа для 2-sat

.. task::

    Дан граф. Нужно выбрать часть вершин так, чтобы для каждого ребра был отмечен один из концов и максимальная разница между номерами выбранных вершин была минимальна.
    |
    |
    
    
    Сделаем бинпоиск по ответу. Тогда мы не можем брать вершины с номерами ближе `mid`, но если мы это будем выражать в виде единичных импликаций их количество может быть до `N^2`, поэтому нужно ввести фиктивные вершины которые будут отвечать за отрезки длиной `N, N/2, N/4...` также как в Дереве Отрезков. Таким образом мы накладываем 2 вида огранчений: на номера и на рёбра, а затем используем 2-sat. 
    Для тренировки можно сдать эту задачу: https://codeforces.com/problemset/problem/1903/F
            
    
    |

.. task::

    Дан граф. Дано множество троек состоящих из чисел `x, y` и строки `s`, таких что на пути от `x` до `y` количество вершин это длина `s`. Нужно дать каждой вершине букву в соответствие так, чтобы для каждой тройки на пути от `x` к `y` была написана строка `s` в прямом или обратном порядке.
    |
    |
    
    
    Сделаем вершины отвечающие за то, напечатана ли конкретная строка и за то какая буква в конкретной вершине. Очевидно для каждой вершины это не больше двух варинтов если она есть хотя бы на одном пути, а иначе в неё можно ставить любую букву. Ограничения будут между символами в одной вершине, и между строками и символами, между парами строк вводить ограничения слишком долго.
    Для тренировки можно сдать эту задачу: https://codeforces.com/contest/1657/problem/F
            
    
    |


что-то

