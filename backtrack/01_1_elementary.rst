.. highlight:: python

.. _backtrack\_elementary:



Элементарные примеры
====================

Я тут долго думал, стоит сначала объяснять общую идею или все-таки
сначала пример разбирать. Буду сначала пример, так, наверное, понятнее.

Перебор всех :math:`2^k` двоичных чисел из :math:`k` разрядов
-------------------------------------------------------------

.. note::
    Это, пожалуй, единственный пример, когда в некоторых случаях
    имеет смысл писать прямой перебор. Действительно, перебрать все
    :math:`k`-значные двоичные числа можно легко:
    ``for i in range(1 << k):`` — и :math:`i` пробежит все
    :math:`k`-значные двоичные числа. Это бывает полезно, например, в
    динамике по подмножествам или динамике по профилю, но нередко бывает
    полезнее рекурсивный перебор, который мы и будем тут разбирать.

    Кроме того, в некоторых языках есть те или иные стандартные функции,
    позволяюще вам сгенерировать определенные комбинаторные объекты без рекурсии.
    Но мы будем обсуждать общий метод, который работает для любого перебора,
    а не только для тех, для которых есть стандартные функции.

Пусть нам надо, например, вывести на экран все :math:`k`-значные
двоичные числа (их всего, очевидно, :math:`2^k`). Напишем следующую
программу

::

    def check(a):
        print(*a)

    def find(i):
        if i == k:
            check(a)
            return
        a[i] = 0
        find(i + 1)
        a[i] = 1
        find(i + 1)

    k = int(input())
    a = [None] * k
    find(0)

и посмотрим, как она работает. Есть массив :math:`a`, в котором будет
накапливаться наше двоичное число, по одной цифре в элементе массива.

Процедура :math:`check` делает то, что надо сделать с очередным
найденным числом: выводит его на экран. Если бы надо было делать что-то
ещё, она бы делала что-то ещё; более подробно я напишу ниже.

Основная часть программы — процедура :math:`find`. Её «\ *основная
идея*\ » — пусть у нас в массиве :math:`a` первые :math:`i` элементов
уже заполнены некоторыми двоичными цифрами, т.е. сформировано некоторое
начала :math:`k`-битового числа. Таким образом, нам осталось перебрать
все возможные окончания этого числа, т.е. все возможные комбинации
на последних :math:`k-i` цифрах. Вот функция :math:`find(i)` именно это
и будет делать.

Более строго, результатом вызова
:math:`find(i)` будет перебор всех возможных :math:`2^{k-i}` «концов»
числа, т.е. вызов процедуры :math:`check` для всех :math:`2^{k-i}`
двоичных чисел с заданным началом. (У нас заполнены первые :math:`i`
элементов, т.е. осталось заполнить :math:`k-i`, потому и
:math:`2^{k-i}` вариантов; элементы массива нумеруются с нуля, поэтому 
:math:`i` обозначает номер первой
незаполненной позиции — позиции, откуда надо начинать заполнять массив
:math:`a`.)



.. _whyworks:



Почему это работает?
--------------------

Попробуем понять, как она работает (т.е. почему сказанное выше про неё
верно). Можно понять это с нескольких сторон (ниже будет несколько объяснений
— этот раздел и следующий — попробуйте понять хотя бы одно.)

Посмотрим с конца.

Во-первых, как работает :math:`find(k)`. Видно, что она просто
запускает :math:`check` и выходит. Но именно это она и должна сделать в
соответствии с «основной идеей». Действительно, вызов :math:`find(k)`
обозначает, что первые :math:`k` элементов массива уже заполнены,
т.е. заполнены *все* :math:`k` элементов, т.е. уже сформировано
очередное решение — осталось только вывести его на экран.

Рассмотрим теперь работу :math:`find(k-1)`. Она сделает следующее:
поставит в :math:`a[k-1]` цифру :math:`0` и вызовет :math:`find(k)`,
которая (как мы только что видели) выведет массив на экран. Потом она
поставит в :math:`a[k-1]` цифру :math:`1` и опять вызовет
:math:`find(k)`, которая опять просто выведет решение на экран.

Это полностью соответствует «основной идее». Действительно, первые
:math:`k-1` элементов массива уже должны быть заполнены, поэтому
осталось только перебрать два варианта заполнения последней цифры и
вывести оба на экран. Именно это она и делает.

Посмотрим теперь :math:`find(k-2)`. К её вызову первые :math:`k-2`
элемента массива уже должны быть заполнены, поэтому осталось перебрать
все варианты заполнения оставшихся двух элементов. Что сделает
:math:`find(k-2)`. Она поставит в :math:`a[k-2]` ноль и вызовет
:math:`find(k-1)`, которая, как мы видели, переберёт все возможные
:math:`1`-циферные окончания и выведет их на экран. Далее, когда
:math:`find(k-1)` отработает, произойдёт возврат в :math:`find(k-2)`, она
поставит в :math:`a[k-2]` единицу и опять запустит :math:`find(k-1)`,
которая переберёт все возможные :math:`1`-циферные окончания такого
начала. Видно, что таким образом :math:`find(k-2)` переберёт все
возможные :math:`2`-циферные окончания решения, сформированного перед её
вызовом, т.е. отработает в соответствии с «основной идеей».

Теперь :math:`find(k-3)`. Ей надо перебрать все возможные
:math:`3`-циферные окончания. Она поставит ноль в :math:`a[k-3]` и
вызовет :math:`find(k-2)`, которая, как мы только что видели,
действительно перебирает все :math:`2`-циферные окончания. После этого
поставит единицу в :math:`a[k-3]` и опять вызовет :math:`find(k-2)`.
Поскольку все :math:`3`-циферные окончания — это либо ноль и
:math:`2`-циферное окончание, либо единица и :math:`2`-циферное
окончание, то вызов :math:`find(k-3)` действительно перебирает все
:math:`3`-циферные окончания.

И так далее [на самом деле выше я просто тремя несколько различными
способами описывал фактически одно и то же. Работа :math:`find(k-3)`
ничем принципиально не отличается от :math:`find(k-2)` и т.п.].

Вообще, :math:`find(i)` надо перебрать все окончания от :math:`i`-ой
цифры до конца массива. Но все такие окончания — это либо ноль и
окончание от :math:`i+1`-ой до конца, либо единица и окончание от
:math:`i+1`-ой до конца. В соответствии с этим :math:`find(i)` и ставит
в :math:`a[i]` ноль и вызывает :math:`find(i+1)`, тем самым перебирая
все окончания от :math:`i+1`-ой цифры до конца, потом ставит в
:math:`a[i]` единицу и опять вызывает :math:`find(i+1)`.

Теперь ясно, что :math:`find(0)` перебирает все :math:`k`-значные
окончания пустого числа (т.е. числа, в котором ноль цифр), т.е.
действительно решает задачу.

.. image:: 01_1_elementary/table.png

Посмотрим теперь на ту же работу с начала (в смысле, не с конца) [на
самом деле то, что я тут пишу — это в некотором смысле тавтология. Я
одно и тоже переписываю в разных вариантах, надеясь, что хотя бы одним
вы проникнетесь :)].

Все двоичные числа можно представить в виде таблицы, приведённой выше:
в первую очередь разделяем числа по первой цифре, во вторую очередь по
второй и т.д. В соответствии с этим и работают процедуры :math:`find`.
Можно себе представить ось времени направленную вертикально вниз, с
верхней границей таблицы — моментом запуска :math:`find(0)`, нижней
границей — концом запуска :math:`find(0)`. Самая левая вертикальная
черта отражает работу :math:`find(0)`: она работает все время. Следующая
вертикальная черта состоит из двух частей: они отражают работу
:math:`find(1)`. Процедура :math:`find(1)` будет запущена дважды
(:math:`find(0)` запустит её дважды), потому две черты. Каждый запуск
:math:`find(1)` запустит :math:`find(2)` два раза — итого четыре запуска
:math:`find(2)`, отражаемые четырьмя кусочками третьей вертикальной
прямой. (все четыре копии будут работать одна за другой, а не
одновременно, ведь вертикальная ось — это ось времени). Видно, что
делает каждая процедура :math:`find`: она ставит в соответствующую
ячейку массива :math:`a` ноль, потом один (цифры справа от вертикальной
черты, соответствующей запуску процедуры), и для каждой цифры запускает
процедуру :math:`find` «следующего уровня» (две вертикальные черты ещё
правее). Видно и как будет в итоге меняться массив :math:`a`: вначале в
нем все нули, потом, начиная с правых цифр, в нем меняются нули на
единицы и т.д., в конце — все единицы.

Наконец, ещё один вариант представления того, что происходит. Он, может,
не так ясно разъясняет работу, но весьма полезен для понимания идей
перебора вообще.

Дерево решений
--------------

Все множество решений (в нашем случае решения — это все
:math:`k`-битовые двоичные числа) можно представить в виде дерева, делая
сначала разделение решений по первому биту, потом по второму и т.д.:

.. image:: 01_1_elementary/tree.1.png

С этой точки зрения работа процедуры :math:`find` очень похожа на поиск
в глубину по этому дереву (если вы знаете, что это такое); 
на самом деле, она и есть поиск в глубину.
Мы сначала обходим левое поддерево корня, проходя ребро и рекурсивно
запускаясь от левого сына корня, после окончания обхода обходим правое
поддерево, проходя соответствующее ребро и рекурсивно запускаясь от
правого сына. Представление о дереве решений нам будет очень полезно в
дальнейшем.

Я надеюсь, что в этом месте вполне понятно, как работает процедура
:math:`find`.

О процедуре :math:`check`
-------------------------

Обратите внимание, что на самом деле, как видно, нам совсем не важно,
что делает процедура :math:`check`. Эта процедура делает то, что нужно в
данной конкретной задаче сделать с найденным решением (в нашем случае —
с найденным :math:`k`-битным числом): надо его вывести на экран —
выведем, надо в файл сохранить — сохраним, надо проверку какую-нибудь
сделать — сделаем и т.д. Для написания собственно *перебора* не важно,
что она будет делать; основная задача перебора — поставлять процедуре
:math:`check` одно за другим решения. Но именно процедура :math:`check`
будет делать то, зачем мы делали перебор: считать такие объекты, или
проверять, подходит ли объект под условие, или искать объект минимальной
стоимости…

Общая идеология поиска
----------------------

Итак, нам надо перебрать объекты из некоторого множества. Более
конкретно — вызвать процедуру :math:`check` для каждого объекта. Таким
образом, основная задача перебора будет состоять в том, чтобы вызвать
процедуру :math:`check` для всех объектов из нашего множества.

Обычно объекты из множества можно задавать некоторым массивом, элементы
которого принимают те или иные значения. В приведённом выше примере это
был массив :math:`a` — массив двоичных цифр; везде ниже я аналогичные
массивы тоже буду обозначать :math:`a`. Обычно перебрать все подходящие
значения одного конкретного элемента массива :math:`a` легко; в приведённом выше
примере каждый элемент массива :math:`a` мог принимать два значения:
ноль и один.

Тогда перебрать все объекты можно с помощью следующей процедуры:

::

    def find(i):
        if выбраны все элементы, т.е. сформировано некоторое решение:
            check()
            return
        для каждого возможного значения a[i]:
            a[i] = это значение
            find(i + 1)

Комментарии:

#. Проверка на то, что решение сформировано. В простейшем случае это
   будет просто ``if i == k``, как выше, но могут быть и более
   сложные варианты (например, если число элементов не фиксировано).

#. Цикл по возможным значениям :math:`a[i]`. Опять-таки, в каждом
   конкретном случае, конечно, свой. Как правило, это будет цикл
   :math:`for`, нередко с вложенным :math:`if`, например,

   ::

        for j in range(n):
            if (j может быть значением a[i]):
                a[i] = j
                find(i + 1)

   примеры будут ниже.

Эта процедура :math:`find` работает аналогично приведённому выше примеру
(и вообще, все процедуры :math:`find` в переборе работают аналогично
друг другу): считая, что начало из :math:`i-1` элемента фиксировано,
перебирает все возможные окончания. Она смотрит, какой может быть
:math:`i`-й элемент, перебирает все его значения, и для каждого
запускает рекурсивно :math:`find(i+1)`, которая переберёт все окончания,
считая первые :math:`i` элементов фиксированными.

Процедура :math:`check` делает то, что надо сделать с решением. В
большинстве случаев это проверка, удовлетворяет ли найденное решение
каким-либо требованиям (примеры см. ниже), поэтом так и названа. Как я
уже много раз говорил, конкретный вид процедуры :math:`check` нам не
важен.

Перебор всех :math:`k`-значных чисел в :math:`n`-ичной системе счисления
------------------------------------------------------------------------

(Всего таких чисел :math:`n^k`)

(Зачем я все время привожу, сколько таких объектов: просто для того,
чтобы вы могли лишний раз проверить, что вы понимаете, о каких объектах
идёт речь: посчитайте сами в уме количество таких объектов и сравните;
никакой больше нагрузки это не несёт.)

::

    def find(i):
        if i == k:
            check()
            return
        for j in range(n):
            a[i] = j
            find(i + 1)

Я надеюсь, что работа этой процедуры если и не очевидна после всего
вышеизложенного, то за несколько секунд становится понятной.
Единственное отличие от примера 1 — то, что надо перебирать не :math:`2`
цифры, а :math:`n`, и потому перебор делаем циклом.

Разложение числа :math:`N` в степени двойки
-------------------------------------------

Несколько притянутый за уши пример: по данному числу :math:`N`
определить, можно ли его представить в виде суммы :math:`k` степеней
двойки, не обязательно различных.

.. note::
    Конечно, эту задачу, как и многие другие, которые мы тут будем
    обсуждать, вполне можно решать другими, более разумными, быстрыми и
    правильными методами, чем перебором, но мы тут будем обсуждать именно
    переборные решения в качестве иллюстрации общих концепций.

Будем перебирать все возможные наборы из :math:`k` степеней двойки;
соответственно, в массив :math:`a` будем записывать последовательно эти
степени.

::

    def check():
        if sum(a) == n:
            print(*a)

    def find(i):
        if i == k:
            check()
            return
        for j in range(31):
            a[i] = 1 << j
            find(i + 1)

Во-первых, я ещё раз привожу текст процедуры :math:`check`, чтобы вы
видели, что она будет делать здесь (а она проверяет, подходит ли нам
такое решение, и, если да, то выводит его на экран).

Во-вторых, обратите внимание на перебор всех степеней двойки циклом по
:math:`j`. Можно, конечно, этот перебор написать и по-другому, например
так:

::

    a[i] = 1
    while a[i] < (1 << 30):
        find(i + 1)
        a[i] <<= 1

или типа того: не суть важно, как написать перебор, главное, правильно
написать, не забыв ни одного варианта; в частности, обратите внимание,
что этот вариант кода, по сравнению с приведённым в процедуре
:math:`find` выше, перебирает на одну степень двойки меньше.

.. task::
    :name: Контрольный вопрос

    Видите, почему?
    |
    Посмотрите, как будет
    заканчиваться цикл while.
    |
    На последней итерации цикла ``a[i]`` станет
    ``1 << 29``, оно обработается, потом удваивается, становится равным
    ``1 << 30``, и происходит окончание цикла. Значение ``1 << 30`` не
    обрабатывается.
    |

Я надеюсь, что в остальном идея работы процедуры понятна.



.. task::

    Напишите эту программу (собственно, я надеюсь, что и
    предыдущие программы вы написали). Потестите её (обратите внимание, что
    тут время работы от :math:`n` не зависит, только от :math:`k`, потому
    имеет смысл брать и большие :math:`n`). Кроме того, заметьте, что одно и то же решение
    выводится несколько раз, отличаясь перестановкой слагаемых. Придумайте,
    как это исправить (может быть, вам поможет сначала почитать следующий
    пример, но лучше подумайте сначала, не читая примера дальше).
    |
    |
    Исключить повторный вывод одного и того же решения можно, потребовав,
    чтобы слагаемые неубывали:
    
    ::
    
        for j in range(31):
            if (1 << j) >= a[i-1]:
    
    
    |

Перебор всех сочетаний из :math:`n` по :math:`k` (т.е. всех :math:`C_n^k`)
-----------------------------------------------------------------------------

Хочется, аналогично тому, что мы делали раньше, в массив :math:`a` записывать выбранные элементы. Но тут
возникнут две проблемы: во-первых, надо, чтобы все элементы были
различными, во-вторых, надо, чтобы сочетания не повторялись из-за изменения
порядка элементов (ведь :math:`\{1,3\}` и :math:`\{3,1\}` — это одно и
то же сочетание).



.. task::

    Можно, конечно, это проверять в процедуре :math:`check`. Т.е.
    процедура :math:`find` будет фактически работать по предыдущему примеру,
    а процедура :math:`check` будет отбирать то, что нужно. Напишите такую
    программу. Обратите внимание на то, чтобы не брать одно и то же
    сочетание несколько раз.
    |
    |
    Проверить неповторяемость можно,
    проверяя, что элементы в массиве идут в неубывающем порядке — т.е. идея
    та же, что и ниже в основном тексте.
    |

Но на самом деле обе проблемы решаются одной идеей: будем требовать, чтобы в массиве
:math:`a` элементы шли строго по возрастанию (поймите, почему это решает обе проблемы!). Тогда получаем следующую
процедуру :math:`find` (считаем, что элементы, из которых мы собираем
сочетание, занумерованы от :math:`0` до :math:`n-1`):

::

    def find(i):
        if i == k:
            check()
            return
        for j in range(n):
            if i == 0 or j > a[i - 1]:
                a[i] = j
                find(i + 1)

Обратите внимание на нетривиальный :math:`for`. Проверка гарантирует,
что все элементы будут идти по возрастанию. На самом деле, очевидно, что
весь :math:`for` можно заменить на

::

    for j in range(a[i - 1] + 1, n):

(только надо аккуратно обойтись со случаем :math:`i=0`).

Кроме того, заметьте, что теперь не все ветви перебора заканчиваются
формированием решения. Действительно, если, например, :math:`k=3`, а мы
на первом же уровне перебора (т.е. в :math:`find(0)`) возьмём
:math:`a[0]=n-1`, то видно, что на втором уровне (т.е. в
:math:`find(1)`) нам будет нечего делать. Аналогично, если :math:`k=3`,
а на первом уровне берём :math:`a[0]=n-2`, то на втором придётся взять
:math:`a[1]=n-1` и на третьем делать нечего.



.. task::

    а) Напишите эту программу. Обратите внимание на подготовку
    вызова :math:`find(0)`; проверьте, что перебираются действительно
    **все** сочетания (например, выводя их в файл и проверяя при маленьких
    :math:`n` и :math:`k`).
    
    б) Добавьте в программу код, который выводит (на экран или в файл) «лог»
    работы рекурсии (например, выводя при присвоении :math:`a[i]=j` на
    экран строку ``a[i]=j`` (с конкретными значениями ``i`` и ``j``, т.е. ``print("a[", i, "]=", j)``),
    сдвинутую на :math:`i` пробелов от левого
    края строки: вам этот вывод покажет, что на самом деле делает программа
    и пояснит предыдущий абзац); этот «лог» лучше выводить вперемешку с
    найденными решениями, чтобы видеть, какая ветка рекурсии чем
    закончилась. (Вообще, такой «лог» — очень полезная вещь при отладке программ с перебором.)
    Подумайте над тем, как исправить то, что описано в
    предыдущем абзаце, т.е. как сделать так, чтобы каждая ветка рекурсии
    заканчивалась нахождением решения.
    |
    а) Подумайте, почему некоторые ветки не находят решения и как это
    исправить.
    |
    а) Понятно, что в :math:`find(i)` бессмысленно ставить :math:`a[i]=n-1`,
    если только :math:`i` не равно :math:`k-1`. Вообще, ясно, что не имеет
    смысла ставить :math:`a[i]>n-(k-i)` (вроде так, может быть
    :math:`\pm1`, подумайте), т.к. элементов на оставшиеся места не хватит.
    Поэтому стоит делать цикл от :math:`a[i-1]+1` до :math:`n-(k-i)`.
    |

Замечу ещё, что в этой задаче можно написать процедуру :math:`find`
немного по-другому. А именно, будем ей теперь передавать два параметра,
:math:`i` и :math:`x`. Смысл параметра :math:`i` тот же, что и раньше, а
:math:`x` обозначает, начиная с какого числа надо перебирать очередной
элемент:

::

    def find(i, x):
        if i == k:
            check()
            return
        for j in range(x, n):
            a[i] = j
            find(i + 1, j + 1)

На самом деле тут :math:`x` будет всегда равен :math:`a[i-1]+1`, просто,
может быть, такую процедуру проще понять, ну и проще разобрать
случай ``i==0`` (поймите, как!).

Смысл процедуры :math:`find` теперь такой: перебрать все возможные
окончания нашего сочетания, в которых все элементы не меньше, чем
:math:`x`.

Вообще, иногда и в других задачах имеет смысл передавать процедуре
:math:`find` дополнительные параметры, которые так или иначе
ограничивают область перебора очередного элемента, точнее, подсказывают,
какие значения элемента стоит перебирать. Как правило, их (параметры)
всегда можно выразить через уже сформированную часть решения, но иногда
проще их передавать, чем каждый раз пересчитывать.

Перебор всех :math:`n!` перестановок из :math:`n` чисел (от :math:`0` до :math:`n-1`)
--------------------------------------------------------------------------------------

Здесь из двух проблем, перечисленных в начале предыдущего примера, осталась
одна: надо, чтобы все элементы перестановки были различными. Порядок же,
наоборот, как раз таки важен, и поэтому такой приём, как в прошлом
примере, здесь не пойдёт.

Поэтому применим другой приём, который весьма полезен бывает во многих
задачах на перебор. А именно, введём второй глобальный массив, массив
:math:`was`, в котором будем фиксировать, использовали ли мы каждое
число. Т.е. очередным элементом в перестановку будем ставить только те
числа, которые ещё не были использованы. (Естественно, в массиве
:math:`a` будем хранить получающуюся перестановку).

::

    was = [False] * n

    def find(i):
        if i == n:
            check()
            return
        for j in range(n):
            if not was[j]:
                a[i] = j
                was[j] = True
                find(i + 1)
                was[j] = False

Во-первых, тут у нас количество элементов в объекте, которое раньше было
:math:`k`, теперь равно :math:`n` — общему количеству элементов, поэтому
такое условие выхода из рекурсии.

Во-вторых, как собственно работает процедура :math:`find(i)`. Она
перебирает, какой элемент надо поставить на :math:`i`-е место. Этот
элемент не должен быть использован ранее (т.е. не должен уже стоять в
массиве :math:`a`), потому и проверка ``if not was[j]:``. Далее, она ставит
этот элемент в массив :math:`a`, помечает, что он теперь использован и
запускает :math:`find(i+1)` для перебора всех «хвостов» текущей
перестановки. При этом переборе элемент :math:`j` использован уже не
будет, т.к. в :math:`was[j]` помечено, что он уже взят. Надеюсь, что
работа процедуры понятна.



.. task::

    Напишите программу перебора всех :math:`A_n^k`
    — всех размещений из :math:`n` по :math:`k` (в них, в отличии от
    :math:`C_n^k`, порядок важен).
    |
    |
    То же, что и для перестановок,
    только проверка на выход из рекурсии будет ``if i>k``, а не
    ``if i>n``.
    |

Откат состояния
^^^^^^^^^^^^^^^

А теперь обратите особое внимание на строчку

::

        was[j] = False

в приведённом выше тексте. Обсуждению её мы посвятим почти всё
оставшееся в текущей части время. Она является примером очень важной
идеи, пожалуй, самого важного правила, которое есть при написании
переборных программ. Именно несоблюдение этого правила (а точнее,
забывание про него), на мой взгляд, является одним из основных
источников ошибок в переборе, поэтому всегда, когда пишете перебор,
помните про него:

.. important::

    Процедура :math:`find` должна всегда возвращать назад все изменения,
    которые она производит (за небольшими исключениями, когда вы чётко
    осознаете, почему некоторое изменение можно не возвращать назад), причём
    лучше всего возвращать назад изменения сразу после вызова
    :math:`find(i+1)`.

Здесь процедура :math:`find` пометила, что элемент :math:`j`
использован. Строка

::

        was[j] = False

отыгрывает назад это изменение, что вполне логично, т.к. процедура
:math:`find(i+1)` переберёт все окончания, у которых на :math:`i`-м
месте стоит :math:`j`, и после этого мы будем перебирать другие
варианты, в которых элемент :math:`j` больше (пока) не используется.
Очевидно, что, если бы этой строки не было, это привело бы к глобальным
ошибкам в работе программы. Если вам это не очевидно, то тщательно
продумайте этот момент; это важно и на самом деле это показывает,
насколько хорошо вы понимаете работу перебора. Если никак не можете
понять, в чем дело, вспомните аргументацию раздела «:ref:`whyworks`»,
и промоделируйте аналогично работу в этом случае. Или напишите программу
с «логом» работы и посмотрите, что пойдет не так.

Другие программы могут делать изменения в других (глобальных)
переменных; примеры будут потом. И всегда надо тщательно проверить, что
откат назад происходит. В простых случаях поможет просто вручную
изменять значения назад, как в примере выше. В более сложных случаях
может быть не так просто отыграть все изменения. В таком случае может
помочь сохранение старых переменных в стеке процедуры и восстановление
их целиком, например

::

    def find(i):
        o_was = was[:]  # сохраняем старый массив
        if i == n:
            check()
            return
        for j in range(n):
            if was[j] == 0:
                a[i] = j
                was[j] = 1
                find(i + 1)
                was = o_was[:]  # восстанавливаем его

    n = ...
    a = [None] * n
    was = [False] * n
    find(0)

Один из минусов этого подхода — то, что довольно активно расходуется
память в стеке, но зато не надо тщательно следить за всеми изменениями,
которые делает :math:`find`, и не надо думать, какой же командой надо
откатить изменения (здесь это было очевидно, но могут быть более сложные
случаи).

Обратите внимание вот ещё на что: кажется, что эту же процедуру можно
написать по-другому, так, чтобы она восстанавливала массив :math:`was`
*до* работы:

::

    def find(i):
        o_was = was[:]
        if i == n:
            check()
            return
        for j in range(n):
            was = o_was[:]
            if was[j] == 0:
                a[i] = j
                was[j] = 1
                find(i + 1)

Но не очевидно, что этот вариант будет работать, т.к. последнее
изменение не будет «откачено», и после окончания процедуры :math:`find`
массив was будет не таким, каким он был раньше (на самом деле его тут же
исправит восстановление массива на уровень выше, но как минимум не
очевидно, что это будет работать, надо думать). Поэтому старайтесь
восстанавливать все изменения как можно раньше.

Кстати, ещё обратите внимание: *все* программы, которые мы до сих пор
писали, изменяют массив :math:`a` и *не* откатывают изменения. Поймите,
почему *это* не страшно.

Совсем общая концепция перебора
-------------------------------

Все задачи до сих пор у нас в основном крутились вокруг некоторого
массива :math:`a`, который мы последовательно заполняли. Действительно,
очень многие задачи, решаемые рекурсивным перебором, можно представить
именно так — как задачу перебора возможных заполнений некоторого массива
:math:`a`.

Но перебор, на самом деле, намного более мощная идея. Пусть у нас есть
задача, в которой нам надо перебрать набор решений, а каждое решение
образуется некоторой последовательностью «элементарных» шагов. То есть
пусть мы можем говорить о каких-то «состояниях», «позициях» в этой
задаче, из каждого состояния/позиции есть набор «ходов» в другие
позиции, и нам надо найти последовательность ходов, приводящую к
требуемой «конечной» позиции (или посчитать, сколько таких
последовательностей есть, или найти оптимальную из них и т.д.) При этом
будем считать, что у нас нет зацикливаний: мы не можем из одной позиции
сделать несколько ходов и вернуться в нее же.

Тогда эта задача несложно решается перебором. Процедура ``find`` будет
работать так: она будет считать, что у нас уже сформирована некоторая
позиция. Процедура будет перебирать все возможные ходы из этой позиции,
и рекурсивно запускать себя из полученных позиций.

Простейший пример — карточный пасьянс типа косынки. У нас есть текущая
позиция (не будем сейчас обсуждать, как ее представить в программе;
будем также считать, что мы знаем все закрытые карты, иначе ответ не
определен). Мы хотим определить, сойдется ли пасьянс, т.е. есть ли такая
последовательность наших действий, при которой пасьянс сходится.

Если бы в каждый момент у нас был бы лишь один возможный ход, то задача
была бы простой: мы просто делали бы эти ходы и посмотрели бы на
результат.

Но в «косынке» из каждой позиции у нас может быть несколько ходов.
Поэтому процедура ``find`` будет работать так: по данной позиции она
будет перебирать все возможные ходы и рекурсивно запускаться для поиска
дальнейшего решения.

::

    def find():
        if ходов нет:
            check()
            return
        for все возможные ходы:
            сделать ход
            find()
            откатить ход назад  # (!!)

Еще пример — крестики-нолики на поле :math:`3\times 3`. Пусть нам надо
написать программу, которая будет искать оптимальный в некотором смысле
ход из данной позиции. Для простоты оптимальность определим так:
оптимальным будем называть такой ход, после которого мы точно сможем
выиграть независимо от ходов противника. Если таких ходов несколько,
выберем любой из них. Если таких ходов нет, но есть ходы, гарантирующие
нам ничью, то выберем любой из ничейных ходов. Если же все ходы ведут к
нашему проигрышу (при условии идеального соперника), то сообщим об этом.

(Отмечу, что «оптимальность» хода можно было бы определить и сложнее,
например, попытаться как-то учесть возможность противнику ошибиться. Но
мы так усложнять не будем.)

Для этого просто переберем все возможные способы развития партии,
начиная с некоторой позиции. Теперь наша функция ``find`` будет возвращать значение. 
Она будет принимать в качестве параметра, кто (крестики или
нолики) ходят сейчас, и будет возвращать, кто выигрывает при идеальной
игре обоих соперников. Код будет примерно такой:

::

    def find(player):  # player = -1 -- нолики, player = 1 -- крестики
        # проверить, не окончена ли игра (т.е. выиграл ли уже кто-то и не заполнено ли поле)
        if игра окончена:
            if крестики выиграли:
                return 1
            elif нолики выиграли:
                return -1
            else
                return 0 # ничья
        # переменная optimal хранит номер выигрывающего игрока (-1, 0 или 1)
        # изначально худший для нас вариант -- выигрывает противник
        optimal = -player  # -player как раз дает противника
        for i in range(3):
            for j in range(3):
                if клетка (i, j) свободна:
                    сходим в клетку (i, j)
                    winner = find(-player)  # рекурсивно переберем дальнейшие варианты
                                            # и узнаем, кто выигрывает
                    if player == 1:
                        # для крестиков мы хотим
                        # номер выигрывающего игрока как можно больше
                        # т.е. крестики лучше ничьей, а ничья лучше ноликов
                        if winner > optimal:
                            optimal = winner
                    else:
                        # player == -1 -- нолики
                        # для ноликов мы хотим
                        # номер выигрывающего игрока как можно меньше
                        # т.е. нолики лучше ничьей, а ничья лучше крестиков
                        if winner < optimal:
                            optimal = winner  
                    отменим ход в (i, j)  # откатимся!!
        # теперь optimal --- выигрывающий игрок при самом лучшем нашем ходе
        return optimal



.. task::

    (Сложное) Напишите эту программу полностью и доведите ее до
    такого состояния, чтобы можно было играть с компьютером в
    крестики-нолики.
    |
    |
    |

Так можно решать практически любую игру, в которой не бывает
зацикливаний. (А на самом деле если зацикливания возможны, то первый
вопрос — а что происходит в реальной игре в таким случае? Ведь вряд ли
игра на самом деле будет продолжаться до бесконечности? В шахматах,
например, при трехкратном повторении позиции объявляется ничья, поэтому
зацикливания невозможны, просто надо хранить все позиции, которые уже
встречались.)

Правда, конечно, есть проблема — если игра сложная, с множеством ходов и
длинными партиями, то времени перебрать все возможные партии не хватит.
Например, в шахматах таким перебором решаются разве что малофигурные
эндшпили.

Еще пример такой задачи:



.. task::

    (`Задача «резисторы» <https://algoprog.ru/material/p159>`_) Радиолюбитель Петя
    решил собрать детекторный приемник. Для этого ему понадобился
    конденсатор емкостью :math:`C` мкФ. В распоряжении Пети есть набор из
    :math:`n` конденсаторов, емкости которых равны :math:`c_1`, :math:`c_2`,
    …, :math:`c_n`, соответственно. Петя помнит, как вычисляется емкость
    параллельного соединения двух конденсаторов
    (:math:`C_{new} = C_1 + C_2`) и последовательного соединения двух
    конденсаторов (:math:`C_{new} = C1\cdot C2/(C1+C2)`). Петя хочет спаять
    некоторую последовательно-параллельную схему из имеющегося набора
    конденсаторов, такую, что ее емкость ближе всего к искомой (то есть
    абсолютная величина разности значений минимальна). Разумеется, Петя не
    обязан использовать для изготовления схемы все конденсаторы.
    
    Напомним определение последовательно-параллельной схемы. Схема,
    составленная из одного конденсатора, – последовательно-параллельная
    схема. Любая схема, полученная последовательным соединением двух
    последовательно-параллельных схем, – последовательно-параллельная, а
    также любая схема, полученная параллельным соединением двух
    последовательно-параллельных схем, – последовательно-параллельная.
    Обратите внимание, что это определение не допускает произвольные схемы,
    а только полученные именно последовательностью параллельных или
    последовательных соединений.
    |
    |
    |

Дополнительные задачи
-----------------------------------------------

Я надеюсь, что вы решите одну-две задачи и хотя бы *серьёзно* (хотя бы
день) подумаете над остальными (или решите их), прежде чем переходить к
части :ref:`backtrack\_cuts`. Часть из (нормальных переборных)
решений этих задач используют идеи, про которые я буду рассказывать в
части :ref:`backtrack\_cuts`, но будет неплохо, если вы додумаетесь
до них сами :), или как минимум если напишете что-то хоть и корявое, но
работающее.

Точнее, сначала убедитесь, что материал части
текущего раздела (:ref:`backtrack\_elementary`) у вас «осел» в голове, 
и что вы этот раздел понимаете (а для этого прорешайте
задачи из основного текста раздела), потом решайте
задачи. Если не решите (подумав над задачами хотя бы некоторое время,
день-два), смотрите подсказки. Попробуйте учесть их и подумать над
задачами ещё. Потом разберите решения. Может быть, последние три задачи
вам покажутся нетривиальными — ну хотя бы попробуйте их решать…



.. task::

    Напишите программу перебора всех последовательностей длины :math:`n`, 
    состоящих из нулей и единиц, в которых не встречается :math:`k` нулей подряд.
    (Например, при :math:`k=2` и :math:`n=3` это будут последовательности
    010, 011, 101, 110 и 111). Основной задачей программы будет посчитать,
    сколько таких последовательностей всего, но имеет смысл выводить их на
    экран (или в файл) для проверки.
    
    а) Напишите эту программу, модифицировав пример 1, т.е перебирая все
    последовательности из 0 и 1 длины :math:`n`, и проверяя, что
    последовательность «правильная», только в процедуре :math:`check`.
    
    б) Напишите программу, которая будет перебирать только такие
    последовательности, т.е. чтобы каждая ветка перебора заканчивалась
    нахождением решения, и в процедуре :math:`check` проверки не были бы
    нужны.
    
    в) (дополнительный пункт, не имеющий отношения к перебору) Если вы
    раньше не сталкивались с такой задачей, то попробуйте найти несложную
    закономерность ответов при фиксированном :math:`k` (т.е. сначала
    посмотрите на ответы на задачу при :math:`k=2` и найдите в них
    закономерность, потом поищите закономерность при :math:`k=3`, потом при
    :math:`k=4` и т.д.) Кстати, не забудьте, что тестить имеет смысл и
    очевидный случай :math:`k=1` :)
    |
    б) Можно дописывать ноль, только
    если текущая последовательность заканчивается меньше, чем на :math:`k-1`
    нулей. Можно каждый раз считать заново, на сколько нулей заканчивается
    текущая последовательность, а можно передавать в :math:`find`
    дополнительный параметр — сколько нулей стоят в конце текущей
    последовательности. Попробуйте написать оба способа.
    |
    б) Ну понятно:
    будем ставить ноль только при условии, что среди предыдущих :math:`k-1`
    символов есть единицы. Для :math:`k=2` это написать просто:
    
    ::
    
        def find(i):
            if...
                check()
                return
            a[i] = 1
            find(i + 1)
            if a[i - 1] == 1:  # ставим ноль, только если предыдущий символ -- 1
                a[i] = 0
                find(i + 1)

    
    только тут надо будет убедиться, что :math:`i > 0`, чтобы
    не обратиться к последнему элементу массива.
    
    Для больших :math:`k` можно писать цикл, который будет считать, на
    сколько нулей заканчивается текущая последовательность (только аккуратно
    с :math:`a[-1]`, :math:`a[-2]` и т.д., чтобы последовательности могли
    начинаться с нулей) — попробуйте это написать!, — а можно это не считать
    каждый раз заново, а передавать в :math:`find` дополнительным
    параметром:
    
    ::
    
        def find(i, l):
            if...
                check()
                return
            a[i] = 1
            find(i, 0)  # на конце текущей последовательности единица, т.е. ноль нулей :)
            if l < k - 1:  # можно дописать еще один ноль
                a[i] = 0
                find(i + 1, l + 1)  # стало на один ноль больше

    
    в главной программе тогда надо вызывать :math:`find(1, 0)` и никаких
    проблем с :math:`a[0]` и т.п.
    
    в) Закономерность обсудим в теме “Динамическое программирование”.
    |



.. _matching:
.. task::

    Паросочетание в произвольном графе. Рассмотрим граф с
    :math:`2N` (т.е. чётным) количеством вершин. Паросочетанием в нем
    назовём набор из :math:`N` рёбер, у которых все концы различны (т.е.
    каждая вершина соединена ровно с одной другой: разбиение вершин на
    пары). [В олимпиадном программировании обычно рассматривается только
    паросочетание в двудольном графе, т.к. там есть простой эффективный
    алгоритм. Но у нас граф будет произвольным и мы будем решать задачу
    перебором]. [Т.е. смысл этой задачи на самом деле — чтобы вы умели
    перебирать все разбиения на пары]
    
    а) Напишите программу, которая будет перебирать все разбиения вершин на
    пары и проверять, является ли такое разбиение паросочетанием (т.е. все
    ли нужные ребра присутствуют в нашем графе).
    
    б) Считая, что граф полный и взвешенный, напишите программу, которая
    найдёт паросочетание наименьшего веса.
    |
    На самом деле вариант а)
    отличается от варианта б) только процедурой :math:`check` и возможными
    отсечениями (см. раздел :ref:`backtrack\_cuts`). Основное в процедуре :math:`find` у них
    одно и то же: перебор всех разбиений :math:`N` объектов на пары.
    Пожалуй, основной нетривиальностью, над которой придётся подумать, тут
    будет то, что в :math:`find(i)` может оказаться, что :math:`i`-я вершина
    уже с кем-нибудь спарена. Можно предложить два варианта решения
    проблемы:
    
    1. Можно в массиве хранить *список выбранных рёбер* (!): он тогда будет 
    массивом пар чисел.
    Переменная :math:`i` в :math:`find` будет указывать, какое ребро мы
    хотим выбрать (в смысле, :math:`i=0` значит, что мы ещё не выбрали ни
    одного ребра, :math:`i=1` — что выбрали одно и т.д.).
    
    В процедуре :math:`find` теперь ищем первую вершину, которая ещё не
    «спарена», т.е. не является концом ни одного из взятых ещё рёбер, её
    обязательно берём, и перебираем ей пару. Для того, чтобы не тратить
    время на проверку, «спарена» ли вершина, можно завести массив
    :math:`was`, в котором отмечать, спарены ли вершины (и не забывать
    откатывать!)
    
    Это решение довольно прямо идёт по естественной идеологии перебора: нам
    надо выбрать :math:`N` рёбер — так и будем их последовательно выбирать,
    записывая номера выбранных в массив :math:`a`.
    
    2. Но можно делать и, как мне кажется, проще. Можно в массиве :math:`a`
    хранить номер «парной» вершины к данной вершине: т.е. :math:`a[i]` —
    номер вершины, парной к :math:`i`, или -1, если вершина пока ещё не
    спарена. В частности, для уже спаренных вершин обязательно должно быть
    :math:`a[a[i]]==i`. Процедура :math:`find(i)` будет перебирать пары к
    :math:`i`-ой вершине. А именно, если она уже с кем-то спарена, то
    перебирать нечего, иначе перебираем все свободные вершины в качестве
    пары. Массив :math:`was` тут не нужен, т.к. «спаренность» вершины можно
    проверять, проверяя :math:`a[i]==-1`. Обратите особое внимание на то, что
    здесь придётся откатывать изменения в массиве :math:`a`! — это довольно
    редкий случай, но вот вам пример, когда это действительно нужно.
    
    |
    Общий текст для пунктов а) и б) (как уже было отмечено в подсказках,
    процедура :math:`find` почти не отличается для них); в части II вам
    будет предложено придумать отсечения здесь.
    
    В соответствии с вариантом 1 из подсказок:
    
    ::
    
        def find(i):  # выбираем i-е ребро паросочетания
            if i>=n:
                check()  # процедура check разная в вариантах а и б
                return
            # найдем первую свободную вершину
            for j in range(2*n):  # в графе 2*n вершин!
                if not was[j]:
                    break
            # теперь j --- номер первой свободной (не входящей в паросочетание) вершины.
            # Добавим ее в паросочетание и будем искать парную к ней.
            was[j] = True
            for k in range(2*n):  # можно range(j+1, 2*n), т.к. до j-ой все точно спарены
                if not was[k]:  # тут хочется проверить наличие ребра, но пока мы считаем, что это делаем в check
                    was[k] = True
                    a[i] = (j, k)
                    find(i+1)
                    was[k] = False
            was[j] = False  # обратите внимание, что именно здесь!
            # или надо was[j]=0 внутри цикла, но тогда и was[j]=1 тоже!
    
    В соответствии с вариантом 2 из подсказок:
    
    ::
    
        def find(i):  # выбираем парную к i-й вершине
            if i >= 2*n:  # количество вершин в графе --- 2*n, а не n
                check()
                return
            if a[i] != -1:  # парная вершина уже выбрана, перебирать нечего
                find(i+1)
            else:  # надо перебрать все варианты
                for j in range(i+1, 2*n):  # i+1 --- т.к. все до i-ой уже точно спарены
                    if a[j] == -1: 
                        # спарим i-ую и j-ую вершины
                        a[i] = j
                        a[j] = i
                        find(i+1)
                        a[i] = 0
                        a[j] = 0  # !!!обязательно, т.к. иначе i-я и j-я будут считаться еще спаренными    
    |

.. task::

    Напишите программу перебора всех разложений числа :math:`N` на
    натуральные слагаемые.
    
    Вариант 1: ровно на :math:`k` слагаемых
    
    а) считая, что слагаемые могут повторяться и что порядок слагаемых важен
    (т.е. что :math:`2+1` и :math:`1+2` — это разные решения);
    
    б) считая, что порядок слагаемых не важен, т.е. выводя только одно
    разложение из разложений :math:`2+1` и :math:`1+2`, при этом допуская
    одинаковые слагаемые;
    
    в) считая, что все слагаемые должны быть различны, при этом порядок
    слагаемых не важен.
    
    Вариант 2: на сколько угодно слагаемых в тех же трёх подвариантах (а, б
    и в)
    
    Написав программы, прежде чем тестировать их, ответьте в уме на такой
    вопрос: ваша (уже написанная!) программа в варианте «а» будет при
    :math:`n=3` выводить решения :math:`1+2` и :math:`2+1`. А при
    :math:`n=2` она будет выводить :math:`1+1` один раз или два раза (во
    второй раз как будто переставив единички)?
    |
    Можно ввести
    дополнительную глобальную переменную, в которой хранить текущую сумму
    слагаемых, в процедуре :math:`find` увеличивать её на то слагаемое,
    которое поставили, и не забывать потом вернуть назад. Можно поступить
    по-другому: передавать в процедуру :math:`find` дополнительный параметр,
    который обозначает, сколько ещё осталось разложить (т.е.
    ``N - (сумма уже выбранных слагаемых)``). При этом тогда
    очередное слагаемое будет ограничено сверху значением этого параметра.
    Вариант 2: подумайте, какое должно быть условие выхода из рекурсии.
    
    |
    Варианты а, б, в различаются только тем, что в в) достаточно
    потребовать, чтобы слагаемые строго возрастали, в б) — неубывали, а в а)
    это все не имеет значения.
    
    Разберём вариант 1в): заведём глобальную переменную :math:`s`, в которой
    храним текущую сумму.
    
    ::
        
        def find(i):
            global s
            if i == k then
                check()
                return
            for j in range(a[i-1]+1, n-s+1):  # слагаемое должно быть больше предыдущего, но явно не больше, чем n-s
                a[i] = j
                s = s + j
                find(i + 1)
                s = s - j  # откатываем изменения !!!
    
    Обратите внимание, что в процедуре :math:`check` придётся проверять, что
    :math:`s=n`.
    
    Варианты 1б и 1в отличаются только нижней границей цикла: :math:`a[i-1]`
    и :math:`1` соответственно.
    
    Вариант 2 отличается, в первую очередь, условием выхода из рекурсии. Тут
    несложно видеть, что условие выхода из рекурсии будет ``if s==n``, и в
    :math:`check` проверять ничего не придётся.
    
    Можно писать и по-другому, не вводя переменную :math:`s`, а в процедуру
    :math:`check` передавая оставшуюся сумму :math:`rem`; теперь процедура
    :math:`find` будет иметь смысл «разложить число :math:`rem` на
    слагаемые» с какими-нибудь условиями. Например для 2а:
    
    ::
    
        def find(i, rem):
            if rem == 0:  # если rem=0, то мы разложили уже всё N, т.е. нашли решение
                check()
                return
            for j in range(a[i-1]+1, rem+1):
                a[i] =j
                find(i + 1, rem - a[i])  # осталось разложить rem-a[i]
    
    Можно в :math:`find` передавать и текущую сумму, и т.д. — как вам
    приятнее.
    |



.. task::

    Задача «Числа». Дана последовательность из :math:`N` чисел. За
    одно действие разрешается удалить любое число (кроме крайних), заплатив
    за это штраф, равный произведению этого числа на сумму двух его соседей.
    Требуется удалить все числа (кроме двух крайних) с минимальным суммарным
    штрафом.
    
    У этой задачи есть (не самое тривиальное) динамическое решение, но
    напишите переборное решение. Тут надо перебрать все варианты удаления
    чисел и выбирать из них тот, который даст минимальный штраф.
    |
    В
    массиве :math:`a` будем хранить последовательность удалений (на самом
    деле, тут нам массив :math:`a` практически не будет нужен). Стоит (в
    добавок к массиву :math:`a`) хранить ещё один глобальный массив, в
    котором будет храниться текущее состояние чисел, и ещё глобальную
    переменную — текущий штраф. При удаление очередного числа надо
    откорректировать глобальный массив, удалив из него это число (и сдвинув
    другие числа), а также изменить текущий штраф. Не забудьте все
    отыгрывать назад.
    
    Но более продвинутый вариант — хранить текущее состояние чисел связным
    списком, а не массивом, тогда удалять и добавлять элементы просто.
    
    |
    Разберём в разделе
    :ref:`Numbers\_Adv`.
    |

.. _Numbers\_simple:





.. task::

    (Какая-то довольно искусственная задача, но хорошо подходит
    для иллюстрации одной из идей далее). Посчитать количество
    последовательностей из :math:`m` нулей и :math:`n` единиц,
    удовлетворяющих следующих условиям. Первое условие: никакие две единицы
    не должны стоять рядом. Таким образом единицы делят последовательность
    на несколько групп из подряд идущих нулей. Второе условие: количество
    нулей в последовательных группах должно неубывать, и при этом в соседних
    группах должно отличаться не более чем на 1. Эта задача имеет
    динамическое решение, но напишите перебор.
    |
    Простую программу
    перебора написать несложно, только лучше перебирать не
    последовательности из нулей и единиц, а сразу способы разбиения
    :math:`m` нулей на данное количество групп. Т.е. написать функцию
    :math:`count(g,m)`, которая будет считать число способов разбиения
    :math:`m` нулей на :math:`g` групп с учётом второго условия, а в ответ
    выводить :math:`count(n-1,m)+2\cdot count(n,m)+count(n+1,m)`, поскольку
    возможны четыре варианта:
    
    1. Первый и последний символы искомой последовательности — единицы,
    тогда групп нулей у нас :math:`n-1` и потому таких последовательностей
    :math:`count(n-1,m)`.
    
    2. Первый символ — единица, последний — ноль, тогда групп нулей
    :math:`n` и таких последовательностей :math:`count(n,m)`.
    
    3. Первый символ — ноль, последний — единица, тогда групп нулей
    :math:`n` и таких последовательностей опять-таки :math:`count(n,m)`.
    
    4. Первый и последний символы — ноли, тогда групп нулей :math:`n+1` и
    таких последовательностей :math:`count(n+1,m)`.
    
    Функция же :math:`count` будет инициализировать и запускать перебор
    нужных разбиений (т.е. и будет той «главной программой», откуда мы
    запускаем :math:`find(0)`). Массив :math:`a` будет хранить количество
    нулей в очередной группе. Можно проверять отличие соседних групп на 1
    только в :math:`check`, а можно и по ходу перебора.
    
    Но интереснее постараться сделать так, чтобы (почти) все ветки
    заканчивались нахождением решения. Для этого надо, во-первых, сразу в
    переборе перебирать только те разбиения, где количества нулей в соседних
    группах или равно, или отличается на единицу, а во-вторых, проверять,
    хватит ли нам нулей на оставшиеся группы; это мы ещё будем обсуждать в
    разделе :ref:`Perestroika\_adv`.
    |
    Обсудим в разделе
    :ref:`Perestroika\_adv`.
    |

.. _Perestroika\_simple:



