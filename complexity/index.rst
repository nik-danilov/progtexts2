
Сложность алгоритмов
````````````````````

Пожалуй, одним из основных параметров, по которому вы должны выбирать,
подходит ли тот или иной алгоритм для решения задачи на олимпиаде
(естественно, помимо корректности алгоритма) — это его время работы,
или, как говорят, сложность. Когда ещё только собираетесь писать
решение, важно верно оценить его сложность и определить, уложится ли
этот алгоритм в ограничение по времени. Если не укладывается, то,
возможно, стоит поискать другой или как минимум понимать, что ваш
алгоритм будет тормозить.

На самом деле половина, если не больше, приведённого текста здесь вам
скорее для справки, на случай, если в будущем вы будете сталкиваться с
упоминанием о сложности и использованием :math:`O`-обозначений и не
поймёте что-нибудь. В частности, может быть поэтому, текст какой-то
сумбурный (особенно вторая часть) у меня получился.

Простейшие основы
=================

Когда вы придумали алгоритм для какой-нибудь задачи, очень часто бывает важно понять,
насколько быстро он работает. Конечно, вы можете написать программу
и замерить время ее работы на разных тестах, но это, во-первых, сложно
— надо сначала написать программу (а хочется хотя бы примерно
понимать время работы еще до того, как вы начнете писать код — ведь если понятно,
что программа будет медленная, то и писать ее, может быть, не надо,
надо придумать более хорошее решение), а во-вторых, так вы узнаете время работы
только на некоторых тестах (а хочется понимать время работы на более-менее любых тестах).

Есть способ примерно оценить время работы алгоритма на более-менее любых тестах
(точнее, понять, как время работы зависит от теста), даже не написав ни одной строчки кода.
Но начнем мы немного издалека.

Давайте рассмотрим несложную задачу на префиксные суммы — `сумма на отрезке <https://algoprog.ru/material/p2771>`_.
Дан массив из :math:`N` чисел и еще :math:`M` пар чисел. Для каждой пары чисел :math:`(x, y)` надо
посчитать сумму элементов массива начиная с позиции :math:`x` по позицию :math:`y`. Напишем два решения этой задачи.

Первое решение ­— «в лоб», для каждого запроса будем пробегаться от :math:`x` до :math:`y` и считать сумму::

    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    for i in range(m):
        x, y = map(int, input().split())
        s = 0
        for j in range(x, y):
            s += a[j]
        print(s)

И второе решение — использующее :ref:`соответствующую теорию <prefixSums>`::

    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    s = [0]
    for i in range(n):
        s.append(s[-1] + a[i])
    for i in range(m):
        x, y = map(int, input().split())
        print(s[y] - s[x])

Давайте попробуем понять, насколько быстро работают эти решения.
Конечно, так с ходу измерить время в секундах не получится,
это надо запускать решение на конкретном компьютере и на конкретном тесте,
но давайте для начала как-нибудь попробуем хотя бы понять,
какое из решений «дольше». Для этого попробуем посчитать, сколько «действий»
выполняет каждая программа.

Возьмем, например, :math:`N=M=100`. Первая программа будет внешний цикл повторять 100 раз,
и внутри него каждый раз бегать от :math:`x` до :math:`y`. Конечно, дальше все зависит
от конкретных :math:`x` и :math:`y`, но давайте подумаем насчет *худшего* случая
— если подумать, то нас интересует именно самый худший случай, когда программа работает
дольше всего.

Такие случаи, понятно, будут, когда :math:`x` находится в самом начале массива, а :math:`y` — в конце.
Тогда внутренний цикл будет делать примерно 100 операций (прибавлений к :math:`s`).
Общее количество операций, естественно, будет примерно :math:`100\cdot100=10000`.
(Мы, конечно, тут не учли остальные операции, кроме внутреннего цикла — например, считывание :math:`x` и :math:`y`
— но их не так уж и много, 100 штук в нашем примере. Большой разницы между 10100 и 10000 нет.)

А что вторая программа? Она сначала вычисляет массив :math:`s` за 100 действий,
а потом еще за 100 действий вычисляет все ответы. Итого получается 200 действий.
Ясно, что 200 — это намного лучше, чем 10000 — в 50 раз лучше.

А давайте теперь возьмем :math:`N=M=1000`. Несложно понять, что первая программа
будет делать 1000000 (один миллион) действий, а вторая — всего 2000 действий. Уже разница
не в 50, а в 500 раз!

А если мы возьмем :math:`N=M=1000000`, то первая программа будет делать 1000000000000 (миллион миллионов)
действий, а вторая — всего 2000000 (два миллиона), разница в 500000 раз!

Поэтому видно, что вторая программа намного лучше первой, и причем чем больше :math:`M` и :math:`N`,
тем разница становится больше.

Тут на самом деле должен возникнуть справедливый вопрос: а что мы считаем «действием»?
Действием мы считаем какую-нибудь операцию, которая выполняется достаточно быстро,
а точнее — операцию, которая выполняется за одно и то же время, независимо от входных данных.
Например, каждый конкретный ``append`` к массиву выполняется за одно и то же время,
независимо от длины массива или других параметров. (На самом деле это не совсем верно,
но в первом приближении это правда.) Или сложение двух чисел. Или ввод двух чисел с клавиатуры. И т.д.

Конечно, разные «действия» выполняются за разное время, например, приписывание элемента в конец массива
может работать дольше, чем просто суммирование двух чисел (раза в два дольше, допустим), 
а ввод чисел с клавиатуры выполняется весьма дольше, чем сложение (может быть даже в 100 раз дольше). 
Но на самом деле нам это не очень важно. Как мы видели, разница во времени работы двух программ
у нас измеряется тысячами, сотнями тысяч раз. Даже если в одной программе каждое действие
выполняется в 100 раз быстрее, чем в другой, но самих этих действий в 500000 раз больше — 
ну значит вторая программа будет не в 500000 раз быстрее,
а в 5000 раз — но это все равно очень много.

(И на самом деле таких «действий», которые различаются по времени выполнения в 100 раз — их очень немного,
это довольно нетипичная ситуация. Обычно времена выполнения разных «действий» отличаются в 2-10 раз.)

Поэтому не так важно, что мы считаем отдельным «действием». Намного важнее — как количество 
таких «действий» растет с ростом размеров входных данных.

Из того, что мы видели выше, несложно понять, что в первой программе у нас примерно :math:`N\cdot M` действий.
А во второй — :math:`N + M`. Соответственно, говорят так: *сложность* первой программы равна :math:`O(N\cdot M)`,
а второй программы — :math:`O(N + M)`. 

Запись :math:`O(\dots)`, равно как и слово «сложность», указывает на то, что это примерная оценка,
не учитывающая времени выполнения отдельных конкретных действий (но при условии, что каждое действие
выполняется за фиксированное время, не зависящее от размеров входных данных). Формальное определение будет ниже, хотя поначалу не обязательно
в нем разбираться.

Давайте посмотрим еще примеры. Пусть, например, у нас есть следующий код::

    for i in range(n):
        for j in range(n):
            for k in range(n):
                s += i + j + k

Какая у этого кода сложность? У нас три вложенных цикла, каждый длины :math:`N`, внутри выполняются
какие-то простые действия. Общее количество выполнения этих действий будет примерно :math:`N^3`.
Поэтому сложность этого кода есть :math:`O(N^3)`.

Вы можете сказать: у нас внутри этого цикла выполняются три сложения и одно присваивание. 
Значит, сложность есть :math:`O(4N^3)`? Да, но не совсем.
Как мы уже обсуждали выше, не так важно, за какое время выполняется одно действие.
Поэтому мы можем всю сложную операцию считать за одно действие, и сказать, что сложность есть
:math:`O(N^3)`. Говоря по-другому, коэффициент 4 не так важен. Как мы видели выше, разница во времени
выполнения разных программ может измеряться тысячами и сотнями тысяч раз, на это фоне коэффициент 4 ничего не меняет.
Ну будет разница времени выполнения каких-то двух программ не в 100000 раз, а в 25000 раз, какая разница?..

Поэтому в сложности не пишут такие коэффициенты («константы»), которые не зависят от размера входных данных.
Не пишут :math:`O(2N)`, пишут :math:`O(N)`. Не пишут :math:`O(N^2/2)`, пишут :math:`O(N^2)`. Не пишут
:math:`O(2N+3M)`, пишут :math:`O(N+M)`. И т.п.

Еще пример::

    for i in range(n):
        s += i
    for i in range(n):
        s -= i * i

Общее количество действий — :math:`2N` (потому что два цикла длины :math:`N`). Но константы в сложности не пишут,
поэтому сложность — :math:`O(N)`. Говоря по-другому, можно просто мысленно считать прибавление ``s += i`` и вычитание ``s -= i * i``
за одно действие, и тогда получается, что действий только :math:`N`.

Еще примеры::

    for i in range(n):
        j = 1
        while j * j <= n:
            s += j
            j += 1

Здесь внутренний цикл выполняется :math:`\sqrt N` раз. Значит, сложность :math:`O(N\sqrt N)`.

::

    for i in range(n):
        for j in range(i):
            s += j

Здесь тонкость в том, что внутренний цикл выполняется не до :math:`N`, а до :math:`i`. 
На первый взгляд, это усложняет оценку сложности. Общее количество действий будет
:math:`1 + 2 + 3 + \dots + N`. Эта сумма, по формуле суммы арифметической прогрессии, равна :math:`N(N+1)/2`.
Но, во-первых, вспомним, что константы в сложности не пишутся, поэтому получается :math:`N(N+1)`.
А во-вторых, несложно видеть, что :math:`N(N+1)=N^2 + N` — это почти то же самое, что и :math:`N^2`,
потому что при больших :math:`N` второе слагаемое (:math:`N`) намного меньше первого (:math:`N^2`),
поэтому им можно просто пренебречь. Поэтому сложность получается просто :math:`O(N^2)`.

Аналогично, у кода

::

    for i in range(n):
        for j in range(i):
            for k in range(j):
                for l in range(k):
                    s = s + l

сложность :math:`O(N^4)` (можно вывести строгую формулу для общего количества итераций, но можно и просто понять,
что это будет :math:`CN^4+\dots` для какого-то фиксированного :math:`C`, а слагаемыми, замененными на многоточие, можно пренебречь.)

Вообще, по примерам выше можно вывести общее правило:

.. important::

    В **простейших случаях** сложность алгоритма можно оценить,
    просто перемножив максимальное количество итераций во вложенных циклах.

.. note::
    Слова «простейшие случаи» тут важны. Рассмотрим такой пример::

        j = 0
        for i in range(n):
            while j < n and a[j] < i:
                j += 1

    Тут два вложенных цикла, первый идет до :math:`N`, внутренний цикл в худшем случае тоже может сделать :math:`N` итераций
    за один раз. Поэтому может показаться, что сложность :math:`O(N^2)`. Но тут важно то, что внутренний цикл 
    не стартует каждый раз заново с :math:`j=0`, а продолжается с того же :math:`j`, на котором он остановился в прошлый раз.
    Поэтому *общее* количество итераций внутреннего цикла за все время работы программы будет только :math:`N`.
    Говоря по-другому, :math:`j` всегда только увеличивается, а больше :math:`N` оно стать не может, 
    поэтому *общее*, за все время работы программы, количество выполнения операции ``j += 1`` не превосходит :math:`N`,
    поэтому суммарное количество операций во внутреннем цикле будет :math:`N` и сложность равна :math:`O(N)`.

Для наиболее часто встречающихся сложностей есть краткие наименования: алгоритм сложности :math:`O(N)` называют *линейным*,
сложности :math:`O(N^2)` *квадратичным*, :math:`O(N^3)` — *кубическим*.

Все сложности можно упорядочить по возрастанию: алгоритм сложности :math:`O(N)` быстрее, а, значит, как правило лучше,
чем алгоритм сложности :math:`O(N^2)`, а он, в свою очередь, быстрее, чем :math:`O(N^2\sqrt N)`, он быстрее :math:`O(N^3)` и т.д.

Еще бывают алгоритмы, время выполнения которых вообще не зависит от :math:`N` — их сложность обозначают :math:`O(1)`.

Может возникнуть вопрос — что вообще такое :math:`N` в примерах выше? Это какая-то переменная, характеризующая
размер входных данных. В простейших случаях это может быть количество элементов в массиве,
размер матрицы и т.п. Иногда она может называться не :math:`N`, а как-то по-другому, например :math:`M` или :math:`K`,
тогда в записи сложности будет фигурировать имеенно :math:`M` или :math:`K`. Иногда бывает так, что в условии есть
две независимых переменных — как в примере в начале этого раздале, про сумму на отрезке, где были и :math:`N` и :math:`M`.
Тогда в формуле для сложности могут присутствовать обе переменные.

Но вернемся обратно к тому, с чего мы начинали. Мы хотим научиться оценивать время работы программы.
А вместо этого мы научились сравнивать разные алгоритмы между собой (например, квадратичный алгоритм хуже линейного),
но это не отвечает на изначально поставленный вопрос: сколько времени будет работать конкретный алгоритм?

Тут оказывается последным следующее наблюдение:

.. important::

    Современные компьютеры за 1 секунду успевают выполнить примерно 100 миллионов — один миллиард действий.

Поэтому примерно оценить время работы программы очень просто: подставьте максимальное ограничение :math:`N`
в формулу для сложности, разделите результат на 100 миллионов или миллиард — и это даст очень примерное время работы в секундах.

Например, пусть есть алгоритм со сложностью :math:`O(N^2)`, и максимальное :math:`N` равно 1000. Тогда это значит,
что в худшем случае программа сделает миллион действий. Значит, она отработает даже не за секунду, а намного быстрее,
за сотую долю секунды. (Правда, на таких маленьких временах начинаются другие эффекты, например, программа может
потратить какое-то время просто на запуск...) А вот если максимальное :math:`N` равно миллиону,
то значит, что в худшем случае программе надо сделать миллион миллионов действий, и значит она будет работать
тысячу или даже десять тысяч секунд, т.е. несколько часов.

(Почему такой разброс — сто миллионов — миллиард? И на сколько же делить? На самом деле понятно,
что время работы все равно получается очень примерным. Конкретное время уже зависит от того, какое конкретно действия
вы выполняете в программе, и на каком компьютере запускаете код, поэтому не так важно, на что делить, 
все равно ответ примерный. Но если в программе простые действия
— сложения/вычитания, присваивания, умножения, — то можете делить на миллиард. А если сложные — работа с вещественными числами,
извлечение квадратных корней, даже деление, — то на сто миллионов. Но все равно все получится очень примерно.)

Сказанное выше относится в первую очередь к компилируемым языкам программирования — паскалю, C++, Java и т.д.
Интерпретируемые языки, такие как питон или JavaScript, работают намного медленнее, поэтому для них время работы надо еще умножить на 10—100.
(Но вообще, если вы пишете серьезные программы, где очень важна сложность и время работы, то не надо их писать на интерпретируемых языках.)

Обратите внимание, что сложность алгоритма, как правило, можно оценить, даже не написав ни строчки кода.
Прикинуть, сколько у вас будет вложенных циклов, обычно можно в уме. Отсюда получаем следующее правило:

.. important::

    Когда вы придумали алгоритм для какой-нибудь задачи, прежде чем писать код, оцените в уме его сложность
    и проверьте, успеет ли алгоритм на самом большом тесте. А именно, подставьте ограничение на размер теста 
    в сложность, и посмотрите, что получится. На современных олимпиадах ограничение по времени обычно около 1 секуды,
    поэтому если получится 100 миллионов или меньше — алгоритм скорее всего уложится в ограничение. Если получится
    больше миллиарда — вряд ли уложится, попробуйте придумать другой алгоритм. Если же получилось как раз примерно
    100 миллионов — один миллиард, то тут уже как повезет.

    На питоне надо еще умножить оценку, полученную из сложности, на 10-100.

Еще раз: очень важно оценить сложность алгоритма еще до того, как вы начинаете его писать. Нет смысла сдавать решение,
если вы понимаете, что у него плохая сложность — оно точно не пройдет все тесты! (Ну разве что если вы пишете олимпиаду,
на которой оцениваются неполные решения, и ничего лучше не придумали — тогда да, конечно, какие-то баллы вы получите.)

Отдельно скажу про сложность переборных решений. Если вам надо перебрать
все строки из нулей и единиц длины :math:`N`, то сложность будет :math:`O(2^N)` 
(или даже :math:`O(2^N\cdot N)`, если, например, вы каждую строку выводите на экран).
Но сказанное в предыдущих абзацах все равно справедливо: алгоритм сложности :math:`O(2^N)`
уложится в секунду, если :math:`N` не превышает 27—30 (потому что :math:`2^{30}` — это как раз
примерно миллиард). Или, например, если вы перебираете все перестановки из :math:`N` чисел,
то сложность будет :math:`N!`, и в секунду уложится, если :math:`N` не превосходит 11—12.

При этом на самом деле все алгоритмы делятся на два класса — полиномиальные
(где сложность есть :math:`O(N^k)` при каком-то :math:`k`, например, :math:`O(N)`, или :math:`O(N^2)`,
или :math:`O(N^5)` и т.п.; также сюда относятся сложности типа :math:`O(N\sqrt N)` или :math:`O(N^2 \log N)`),
и экспоненциальные (как правило, где сложность вида :math:`O(k^N)` при каком-нибудь фиксированном :math:`k`,
например, :math:`O(2^N)`, или :math:`O(3^N\cdot N)`, или что-нибудь с факториалами типа :math:`O(N!)`
и т.п.). Экспоненциальные алгоритмы работают намного медленнее (как мы видели выше, алгоритм сложности :math:`O(N!)`
работает секунду при :math:`N\approx 12`, а, например, алгоритм сложности :math:`O(N^4)` будет работать секунду при :math:`N\approx 200`,
а если мы поставим ограничение не минуту, а час, то разница станет еще более существенной), поэтому
экпоненциальные алгоритмы стоит использовать только в самых крайних случаях.
Собственно, на основе различия полиномиальных и экспоненциальных алгоритмов строится большая теория
сложностей :math:`P` и :math:`NP`, про нее я пишу ниже, но для начального обучения не обязательно в этом разбираться.

Финальное замечание — вся идеология сложности относится к ситуациям, когда
количество действий в программе достаточно большое.
Если же действий очень мало (например, вы сравниваете квадратичный и линейный алгоритмы
при :math:`N=10`), то намного важнее становится время выполнения отдельных операций.
При :math:`N=10` квадратичный алгоритм делает примерно 100 действий, линейный — примерно 10.
Но вполне может оказаться, что в линейном алгоритме каждая операция работает в 10 раз дольше, и поэтому время выполнения будет одинаковым.
А вот при :math:`N=1000` квадратичный алгоритм делает в 1000 раз больше операций, чем линейный.
Крайне маловероятно (а на практике обычно вообще не встречается), чтобы каждая операция в линейном алгоритме
работала в 1000 раз дольше, чем в квадратичном — а поэтому при :math:`N=1000` квадратичный алгоритм
почти всегда много медленнее линейного. А при еще больших :math:`N` — тем более.

Формальные определения
======================

(Если вы читаете этот текст, перейдя сюда по ссылке с алгопрога, то можете дальше не читать. Дальше идет
более формальный текст, с строгими определениями. Можете почитать, если интересно,
но для базового понимания сложности дальше читать не надо.)



Пример 1: сложность алгоритма Флойда
------------------------------------

Рассмотрим следующую программу (алгоритм Флойда вычисления кратчайших
путей между всеми парами вершин в графе, применённый к задаче поиска
отрицательных циклов в графе, но это пока не важно):

::

    begin
    assign(f,'input.txt');reset(f);
    read(f,n);
    for i:=1 to n do
        for j:=1 to n do
            read(f,w[i,j]);
    close(f);
    for i:=1 to n do
        for j:=1 to n do
            for k:=1 to n do
                if w[j,k]>w[j,i]+w[i,k] then
                   w[j,k]:=w[j,i]+w[i,k];
    ok:=false;
    for i:=1 to n do
        if w[i,i]<0 then
           ok:=true;
    assign(f,'output.txt');rewrite(f);
    if ok then
       writeln(f,'Negative cycles exist')
    else writeln(f,'No negative cycles');
    end.

Попробуем определить, сколько времени займёт выполнение этой программы.
Очевидно, что, прежде чем дать точный ответ на этот вопрос, надо решить
следующие вопросы:

-  Для каких конкретно входных данным мы будем определять время?

-  На каком компьютере будет выполняться программа (в смысле, сколько
   времени займёт выполнение тех или иных операций и т.п.)

-  Возможно, что-то ещё :)

Но, с другой стороны, знание точного времени выполнения на конкретном
компьютере на конкретных входных данных нам не очень-то и нужно, и можно
даже сказать, что вообще не нужно (мы все равно *точно* не знаем компы
жюри, не заем тестов, да и все равно точно все оценить не сможем).

Но зато в условии задачи стоит, скорее всего, ограничение на :math:`N`,
да и понятно, что в первую очередь от :math:`N`, а не от конкретных
входных данных, зависит время работы программы (в смысле, что, если я
увеличу :math:`N` в 10 раз, то программа резко затормозится, а если я,
например, увеличу веса всех, или части, рёбер, то время почти не
изменится). Кроме того, жюри может оказаться очень злобным и подсунуть
самый противный тест, поэтому мы будем интересоваться в первую очередь
временем работы программы *в худшем случае среди всех случаев с данным*
:math:`N`.


.. note::

    Есть редкие исключения, например, QSort, у которого худшие
    случаи встречаются *очень* редко и, если писать QSort рандомизированно
    (т.е. выбирать всегда не средний, а случайный элемент), то никакое даже
    очень злобное жюри не сможет подобрать неприятный тест. Поэтому для
    QSort’а интересуются в первую очередь *средним* временем работы (по всем
    возможным срабатываниям рандома), а не худшим, которое сильно
    отличается от среднего (подробнее далее). Ещё пример — хеширование (если
    вы не знаете, что это такое, то не страшно :) ). Но это — пожалуй,
    единственные исключения. Обычно, во-первых, среднее время не очень
    сильно отличается от худшего, а во-вторых, худший тест подобрать
    реально, и жюри, скорее всего, постарается это сделать.

Итак, нам нужно определить время работы этой процедуры в худшем случае,
причём в первую очередь выделив зависимость от :math:`N`. На самом деле
нас удовлетворит даже не очень плохая оценка сверху (т.е. сойдёт, если
мы приведём функцию, которая всегда даёт чуть большее время, чем на
самом деле). Так как нам все равно неизвестны точные характеристики
компьютера, на котором будет тестирование, да и мы их все равно не
смогли бы учесть, то *абсолютно точно* все равно не получится оценить.

Поэтому заметим, что у нас есть действия, которые выполняются
*фиксированное* число раз, не зависимо от :math:`N` (например,
``read(f,n);`` и т.п.). Обозначим сумму времён выполнения таких операций
(в худшем случае) за :math:`A`. Есть операции, которые выполняются за
время, примерно пропорциональное :math:`N` (последний цикл, *а также*, в
том числе, операции, связанные с внешними циклами: увеличение :math:`i`
на единицу, сравнение его с :math:`N` и т.д.; именно работа с :math:`i`,
а не с :math:`j` или с :math:`k`). Обозначим сумму всех таких времён в
худшем случае (хотя они не сильно зависят от случая) за :math:`BN` (она
пропорциональна :math:`N`, поэтому выделим его в отдельный множитель).
Аналогично, есть команды, которые работают за время, пропорциональное
:math:`N^2` (цикл ввода, *а также* работа с :math:`j`: увеличение на
единицу, сравнение с :math:`N` — в обоих циклах) — обозначим сумму
времён за :math:`CN^2` — и есть команды, работающие за время,
пропорциональное :math:`N^3` (в частности, тот самый внутренний ``if``,
время работы которого действительно зависит от входных данных) —
обозначим сумму времён за :math:`DN^3`.

Общее время работы получается :math:`A+BN+CN^2+DN^3`, причём :math:`A`,
:math:`B`, :math:`C` и :math:`D` здесь некоторые константы, которые,
конечно, зависят от компьютера, для которого мы пишем время, но *не
зависят* ни от :math:`N`, ни даже от конкретного теста при данном
:math:`N` (т.к. мы все суммировали для худшего случая). Заметим, что
точнее этой формулы вряд ли мы сможем что-нибудь сказать, т.к. все равно
не знаем и не можем учесть характеристик компьютера. Кроме того, обычно
все-таки величины :math:`A`, :math:`B`, :math:`C` и :math:`D` не сильно
отличаются друг от друга (ну, максимум раз в десять :) ), а даже при
:math:`N` равном 100 получается, что :math:`N^2` отличается от :math:`N`
в сто раз, и аналогично :math:`N^3` от :math:`N^2`. Ещё хуже будет, если
:math:`N` будет ещё больше. Проще говоря,
:math:`DN^3\gg CN^2\gg BN \gg A`, причём чем :math:`N` больше, тем эти
соотношения выполняются лучше (символ :math:`\gg` обозначает «много
больше», как минимум в несколько раз; точные критерии того, что есть
много больше, зависят от ситуации, конечно). Поэтому в выражении для
времени выполнения можно оставить только старшее слагаемое:
:math:`DN^3`, все равно остальные намного меньше его, и потому результат
изменят не сильно.

.. note::

    Ну и пусть остальные слагаемые увеличат результат на 10% — все
    равно мы точно не знаем :math:`D`, и все равно нам такая точность не
    нужна. Более того, можно выбрать :math:`\delta` такое, чтобы
    :math:`\delta N^3` было всегда больше, чем :math:`A+BN+CN^2` (см.
    подробнее ниже), и тогда, заменив :math:`D` на :math:`D'=D+\delta`,
    можно гарантировать, что :math:`D'N^3` будет *всегда* больше времени
    выполнения программы, т.е. небольшим изменением :math:`D` можно
    добиться того, что остальные слагаемые не будут нужны.
    Т.е. мы нашли неплохую оценку сверху, она
    отличается от правильного времени не очень сильно.

Итак, время работы нашей программы можно неплохо оценить как
:math:`DN^3`, и лучше этого мы все равно ничего не получим. Но :math:`D`
мы все равно не знаем. Поэтому можно говорить, что наша программа
работает *за кубическое время*, за время, *пропорциональное*
:math:`N^3`, не забывая про наличие неизвестного нам постоянного
множителя. Поэтому при оценке сложностей алгоритмов часто используется
:math:`O`-обозначение.

:math:`O`-обозначение
---------------------

Формальное определение :math:`O`-обозначения следующее
(вам, возможно, не обязательно его понимать в деталях, но 
тем не менее попробуйте осознать).
В любом случае ниже будет много примеров.

Пусть у нас есть две функции :math:`f(n)` и :math:`g(n)`, и пусть
существуют такая (не зависящая от :math:`n`) константа :math:`\alpha`,
что :math:`f(n)\leq \alpha g(n)` при любых :math:`n`, начиная с
некоторого. Тогда говорят, что :math:`f(n)` *есть O-большое от*
:math:`g(n)` (или, короче, О от :math:`g(n)`; так и говорят: «о от же от н»), 
и пишут, что :math:`f(n)=O(g(n))`. Замечу, что условие «:math:`f(n)\leq \alpha g(n)`
начиная с некоторых :math:`n`», равносильно условию, что
«:math:`f(n)/g(n)` не превосходит некоторой константы, начиная с
некоторых :math:`n`».


.. note::

    Иногда дают другое определение: :math:`f(n)=O(g(n))`, если существуют
    *две* константы :math:`\alpha _1` и :math:`\alpha _2` такие, что
    :math:`\alpha _1g(n)\leq f(n)\leq \alpha _2g(n)`, начиная с некоторых
    :math:`n`. Эти два определения *не* равносильны: например, в
    соответствии с первым определением, :math:`n^2=O(n^3)`, т.к., начиная с
    :math:`n=1` (т.е. при любых :math:`n\geq 1`) имеем, что
    :math:`n^2/n^3\leq \alpha`, если взять :math:`\alpha`, например,
    равным 1. В соответствии же со вторым определением
    :math:`n^2\neq O(n^3)`. Я далее буду придерживаться первого определения,
    ниже поясню, почему.

Кроме того, иногда вводят ещё множество различных обозначений типа
:math:`\Theta(g(n))`, :math:`\Omega(g(n))`, вообще говоря, ещё и
:math:`o(g(n))` (причём :math:`o` (о-малое) и :math:`O` (о-большое) —
это весьма разные вещи), если хотите посмотреть поподробнее, то смотрите
в Кормене, но имхо обычно это все (кроме :math:`O`-обозначения) не очень
надо.

С использованием :math:`O`-обозначения сложность программы в первом
примере можно записать как :math:`O(N^3)`. Действительно, очевидно, что

.. math:: {AN^3+BN^2+CN+D\over N^3}=A+{B\over N}+{C\over N^2}+{D\over N^3}\leq (A+B+C+D)

при :math:`N\geq1`, поэтому взяв :math:`\alpha=(A+B+C+D)`, мы точно обеспечим выполнение
нужного условия.


.. note::

    Более того, можно взять :math:`\alpha=A+B/10+C/100+D/1000`, и
    условие будет выполнено при :math:`N\geq 10`, можно взять
    :math:`\alpha=A+B/100+C/10^4+D/10^6`, и условие все равно будет
    выполнено при любом :math:`N\geq 100` и т.д. — поэтому видно, что
    константа :math:`A` важнее всех остальных.

Вообще, аналогично можно показать, что для любого полинома :math:`P(n)`
степени :math:`k` (т.е. :math:`P(n)=a_kn^k+\dots+a_1n+a_0`) верно, что
:math:`P(n)=O(n^k)`, и наиболее важным коэффициентом является
:math:`a_k`.

:math:`O`-обозначение указывает на самом деле на поведение функции
:math:`f(n)` при больших :math:`n`, в этом смысле часто :math:`g(n)`
называют *асимптотикой* для :math:`f(n)`.

:math:`O`-обозначение для оценки сложности алгоритмов
-----------------------------------------------------

Таким образом, :math:`O`-обозначение по сути показывает,
чему пропорционально время работы: запись :math:`O(N^3)`
обозначает, что время работы пропорционально :math:`N^3`.

:math:`O`-обозначение почти всегда является очень удобным для
обозначения сложности работы алгоритмов. Действительно, как мы видели,
*абсолютно точно* оценить время работы программы невозможно, да и не
нужно. Самое лучшее, что мы можем сделать — это определить выражение с
точностью до некоторого более-менее постоянного множителя, а
:math:`O`-обозначение как раз и есть то, что сохранит этот результат и
скроет все не важные нам подробности. Кроме того, определять сложность
алгоритмов именно в смысле :math:`O`-обозначения как правило очень
легко, примеры см. ниже.

:math:`O`-обозначение скрывает константу, поэтому если есть две функции
:math:`g(n)` и :math:`h(n)`, которые отличаются в константу раз, т.е.
:math:`g(n)/h(n)` не зависит от :math:`n`, то :math:`O(g(n))` и
:math:`O(h(n))` — это одно и то же. Например, :math:`O(n)`,
:math:`O(2n)`, :math:`O(10n)` и :math:`O(3.14n)` на самом деле
обозначает одно и то же.

Как показывает опыт, на современных компьютерах при современных
ограничениях по времени программа уложится в ограничение по времени,
если ей нужно будет сделать примерно 100 миллионов, может быть миллиард «действий». 
Поэтому
для довольно грубой оценки того, подходит ли тот или иной алгоритм,
можно проверять, укладываетесь ли вы в это ограничение. А именно, если,
например, сложность программы :math:`O(n^3)`, то она обычно уложится во
время при :math:`n`, не превосходящем 400–500, может быть 1000; если сложность
:math:`O(n^2)` — то при :math:`n`, не превосходящем
:math:`8\,000`–:math:`15\,000`, может быть до :math:`30\,000`, и т.д. (в этом смысле выше я и взял
слово «действий» в кавычки: поскольку все равно все оценки
приблизительные, то можно просто подставить :math:`n` в формулу, стоящую
под знаком :math:`O`, и проверить, что получится).


Это и есть **основное практические применение** 
:math:`O`\ **-обозначений на олимпиадах**:

.. important::

    Чтобы оценить, укладывается ли ваше решение в ограничение
    по времени, подставляете максимальное :math:`n` в сложность алгоритма, и
    если результат получается существенно меньше :math:`10^8`, то скорее
    всего укладывается, если существенно больше чем :math:`10^8` (грубо
    говоря, больше чем :math:`10^9`), то вряд ли, иначе у вас пороговый
    случай и придется смотреть внимательнее. 

В последнем случае уже
становится важна «константа»: если «действия» вашей программы простые
(сложения/умножения целых чисел), то скорее всего уложится, 
если же сложные (деление целых чисел, действия с веществеными
числами и т.д.), то вряд ли.

Еще немного про обозначение
---------------------------

Особого упоминания заслуживает обозначение :math:`O(1)`. Это обозначает
(в соответствии с определением выше), что функция :math:`f(n)` не растёт
с увеличением :math:`n`, что есть некоторая не зависящая от :math:`n`
константа, ограничивающая :math:`f(n)` сверху: :math:`f(n)\leq \alpha`.
Поэтому в некотором смысле это обозначает, что время работы не зависит
от :math:`n` (конечно, оно может зависеть, но оно не стремится к
бесконечности с увеличением :math:`n`). На самом деле тот же смысл имеет
обозначение :math:`O(2)` и т.п., но обычно принять писать :math:`O(1)`
(точно также как :math:`O(2n)`, :math:`O(n)`, :math:`O(3.14n)` и т.п. на
самом деле все одно и то же, но пишут обычно :math:`O(n)` и т.п.).

Ещё замечу, что само по себе обозначение :math:`O(g(n))` имеет не до
конца понятный смысл. Чёткий смысл имеет обозначение
«:math:`=O(g(n))`», т.е. вместе с знаком равенства, а без него не
ясно, что такое :math:`O(g(n))`. Например, я могу написать
:math:`O(n)+O(n^2)`, но что это значит, нужно уточнять особо. Если тут
вроде все-таки все более-менее понятно (сумма двух функций, первая из
которых *есть* :math:`O(n)`, а вторая — :math:`O(n^2)`), то если я
запишу, например,

.. math:: \sum_{i=1}^{n} O(i),

то здесь все-таки хочется дополнительных пояснений, а без них
эта запись не имеет особого смысла. Конечно, может
быть, можно определить :math:`O`-обозначение так, чтобы оно и тут давало
однозначную трактовку, но лучше не употреблять :math:`O` вообще нигде,
кроме как в правой части равенств в формате «:math:`=O(g(n))`» (или
в выражениях типа «время выполнения составляет :math:`O(g(n))`\ », что
подразумевает, что :math:`T(n)=O(g(n))`, где :math:`T(n)` — время
выполнения, в худшем случае, например).

Ещё замечу, что :math:`O`-обозначение, как следует из его определения,
вполне может использоваться и для других случаев, не только для описания
времени работы программы. Например, нередко оно используется для
указания количества *памяти*, используемой программой: опять-таки, чтобы
не указывать *сколько вешать точно в байтах*, а указать порядок:
например, правильное решение некоторой задачи требует всего :math:`O(M)`
памяти. Ещё пример на употребление :math:`O`-обозначения не для указания
времени работы программы: пусть мы говорим, что какая-нибудь программа
требует :math:`O(N\log N)` операций с длинными числами — тогда это не
есть сложность (время выполнения) программы, т.к. операции с длинными
числами работают не за :math:`O(1)` (!), но тем не менее это даёт
определённую информацию о времени выполнения. Ещё пример (который будет
употребляться ниже): размер входного файла в какой-нибудь задаче есть
:math:`O(N^2)`.

Примеры
-----------

::

    for i:=1 to n do
        for j:=i+1 to n do begin
            ...
        end;

Общее количество выполнения внутренней части цикла будет
:math:`(n-1)+(n-2)+\dots+2+1=n(n-1)/2=n^2/2-n/2=O(n^2)`, т.к. выражение
является полиномом второй степени. Очевидно, что время выполнения всех
остальных операций в этом цикле будет не больше, чем :math:`O(n^2)`,
поэтому время выполнения всего этого куска кода будет :math:`O(n^2)`.
(Конечно, здесь и далее я считаю, что внутренний кусок кода, заменённый
на ``...``, выполняется за :math:`O(1)`).

::

    for i:=1 to n do
        for j:=i+1 to n do
            for k:=j+1 to n do
                for l:=k+1 to n do begin
                    ...
                end;

Точную формулу количества операций получить, может быть, нетривиально,
но ясно, что будет полином четвёртой степени, поэтому все равно
:math:`O(n^4)`. Конечно, такая программа работает быстрее, чем если бы
все циклы были от 1 до :math:`n`, но на асимптотику это не влияет (см.
ещё ниже).

::

    for i:=1 to n do
        for j:=1 to round(sqrt(n)) do
            ...

Сложность :math:`O(n\sqrt{n})`. На самом деле корни в сложности
встречаются нечасто, обычно только во всяких задачах на проверку чисел
на простоту, а также в условно называемой эвристике :math:`\sqrt{n}`.
Обратите также внимание, что всякие округления делать тут не надо: ну и
что, что :math:`\sqrt n` может не быть целым. У нас все равно везде
стоят *не*\ равенства, да ещё есть произвол в выборе :math:`\alpha`,
поэтому беспокоиться об округлении при записи сложности алгоритма не надо.

::

    for i:=1 to n do begin
        j:=1;
        while j*j<n do begin
              ...
              inc(j);
        end;

Абсолютно аналогично предыдущему.

::

    while n>0 do begin
          ...
          n:=n div 2;
    end;

Количество итераций цикла будет :math:`\log_2 n` плюс-минус несколько.
Поэтому сложность :math:`O(\log n)`. Замечу, что, как известно (может,
вы и не знаете, но все равно это так) логарифмы по разным основаниям
отличаются в константу раз, т.е. для любых :math:`a` и :math:`b`
отношение :math:`\log_a n/\log_b n` равно :math:`\log_a b` и *не*
зависит от :math:`n`, поэтому :math:`O(\log_a n)` и :math:`O(\log_b n)`
на самом деле одно и то же (точно также, как :math:`O(n)` и
:math:`O(2n)` — это одно и то же). Поэтому, когда логарифмы попадаются
под :math:`O`-обозначением, основание как правило не указывают.

::

    for i:=1 to n do ...
    for i:=1 to m do ...

Т.е. два последовательных цикла, один до :math:`n`, второй до
Пока мы не знаем соотношения на :math:`n` и :math:`m`, будем считать,
что это просто два отдельных параметра задачи. В таком случае нас
интересует уже время выполнения как функция :math:`T(n,m)`, а не
:math:`T(n)`, как было раньше. Поэтому и под символом :math:`O` у нас
теперь будут два параметра. Время выполнения этого фрагмента можно
считать равным :math:`T(n,m)=An+Bm` при некоторых :math:`A` и :math:`B`,
и обозначив :math:`C=\max(A,B)`, получим :math:`T(n,m)\leq C(n+m)`,
значит, можно написать :math:`T(n,m)=O(n+m)`. Время выполнения этого
куска есть :math:`O(n+m)`. Вообще, иногда бывает так, что есть
несколько, а не один, параметр, зависимость от которых нас интересует
(самый, пожалуй, частый пример — алгоритмы на графах: в них, как
правило, есть два параметра: число вершин :math:`V` и число рёбер
:math:`E`). В таком случае нередко под :math:`O`-обозначением записана
*сумма* некоторых выражений. Это обычно имеет как раз смысл, аналогичный
указанному здесь.

.. note::

    Заметим, что, вообще говоря, приведённое выше определение
    применить на случай функции нескольких переменных в лоб не получится, но
    несложно его модифицировать так, чтобы все стало хорошо. Я делать этого
    здесь не буду, надуюсь, что идея более-менее понятна, а детали
    реализации определения все равно не очень важны — строго надо бы немного
    по-другому писать все равно.

Последовательность сложностей
-----------------------------

Все возможные асимптотики можно упорядочить от более быстрых к более
медленным. Получится примерно следующее: :math:`\log n`,
:math:`\log^2 n`, :math:`\sqrt[3]{n}`, :math:`\sqrt{n}`, :math:`n`,
:math:`n\log n`, :math:`n\log^2n`, :math:`n\sqrt n`, :math:`n^2`,
:math:`n^3`. (естественно, между каждыми членами этой последовательности
можно вставить ещё сколько угодно асимптотик, потому, в частности, я не
пишу тут нигде многоточий).

Т.е.: все логарифмы идут в порядке увеличения степени, все степени
:math:`n` (:math:`\sqrt n=n^{1/2}`, :math:`n=n^1`, :math:`n^2` и т.п.)
идут в порядке увеличения степени, *любая* степень логарифма идёт *до*
любой степени :math:`n` (в частности, :math:`\log^{100} n` идёт *до*
:math:`\sqrt[100] n`); соответственно, :math:`n\log^k n` при любом
:math:`k` идёт до :math:`n^{1+\varepsilon}` при любом
:math:`\varepsilon>0` и т.п.

Дополнительные замечания
========================

Сложность переборных решений
----------------------------

В отличии от нерекурсивных решений, сложность рекурсивных решений
оценить обычно очень нетривиально, а в случае с переборными решениями
ещё и, как правило, не нужно (в частности, потому я и решил, что тему
про перебор можно давать *до* темы про сложность). Очень грубо время
работы переборного решения можно оценить по количеству листов в дереве
перебора (и именно это количество, т.е. количество перебираемых
вариантов, и стоит сравнивать с величиной 1–100 миллионов), но это, скорее всего,
даже не будет асимптотикой. Ближе к асимптотике будет
подсчёт *общего числа* узлов в дереве, а может, ещё стоит умножить на
количество итераций всяких циклов, которые, может быть, присутствуют в
процедуре find. Но, с другой стороны, считать асимптотику (т.е.
использовать :math:`O`-обозначение) для переборных решений все равно
бессмысленно, т.к., во-первых, при маленьких :math:`n` асимптотика
довольно бессмысленна (она приобретает смысл, т.е. соответствие
реальности, при больших :math:`n`, а в задачах на перебор :math:`n`
обычно мало), а во-вторых, очень сложно оценить действие различных
эвристик и отсечений. Поэтому :math:`O`-обозначение для переборных
решений обычно не используется.

.. note::

    Кстати, обратите внимание, что :math:`3^n\neq O(2^n)`,
    соответственно :math:`2^{2n}\neq O(2^n)` и т.п.

Про QSort подробнее
-------------------

Несложно видеть, что в худшем случае сложность QSort’а есть
:math:`O(n^2)`: если на каждом шагу QSort будет отщеплять один-два
элемента, то глубина рекурсии будет :math:`O(n)`, каждый уровень
рекурсии выполняется за время порядка :math:`O(r-l)`, где :math:`r` и
:math:`l` — границы диапазона, итого порядка :math:`1+2+\dots+n=O(n^2)`.
Но можно показать, что если у вас написан рандомизированный QSort,
то *в среднем* по всем вариантам срабатывания рандома на конкретном тесте с данным :math:`n`
сложность работы QSort’а будет :math:`O(n \log n)`. 

То есть если каждый
раз брать вполне определённый элемент в качестве разделяющего (например,
всегда первый, или всегда средний), то несложно будет злобному жюри
подобрать тест, на котором ваша программа будет работать за
:math:`O(n^2)`. Но, если на каждом шагу выбирать разделяющий элемент
случайно, то никакое злобное жюри не сможет ничего поделать.

О константе
-----------

Как мы видели, :math:`O`-обозначение скрывает константу
пропорциональности: если мы пишем, что время :math:`O(n)`, то это
значит, что при больших :math:`n` время примерно пропорционально
:math:`n`, но коэффициент пропорциональности (константу) мы не
указываем. И логично: абсолютное значение константы нам не нужно: все
равно мы его точно определить не можем. Но если у нас есть *два*
алгоритма, то может иметь смысл *сравнить* их константы. Как правило,
все равно алгоритм с худшей сложностью будет проигрывать по времени, но
при равных асимптотиках иногда имеет смысл оптимизировать константы, да
и иногда алгоритм с меньшей константой, но большей асимптотикой при
конечных :math:`n` (какие и бывают в задачах) может обходить алгоритм
алгоритм с большей константой, но меньшей асимптотикой.

В общем, оптимизировать константу все равно стоит, хотя и во вторую
очередь (в первую очередь оптимизируйте сложность!), особенно если
оптимизировать константу ничего не стоит. Например, пишите
``for i:=1 to n do for j:=i+1 to n do`` вместо
``for i:=1 to n do for j:=1 to n do``, где это можно.

Сложные случаи
--------------

Далеко не у всех решений сложность оценивается так легко, как это было в
предыдущих примерах. Например, рассмотрим следующую программу (найти
четыре одинаковых числа в массиве):

::

    for i:=1 to n do 
        for j:=i+1 to n do if a[i]=a[j] then
            for k:=j+1 to n do if a[i]=a[k] then
                for l:=k+1 to n do if a[i]=a[l] then begin
                    вывести решение;
                    halt;
                end;

Если бы не было команды ``halt;``, то вопросов не было бы: сложность
:math:`O(n^4)` и TL на тестах, в которых много одинаковых чисел. Но
``halt;``, видимо, меняет сложность до :math:`O(n^2)`. Действительно,
если длины все числа разные разные, то в первый же ``if`` программа
никогда не войдёт, и внутренние циклы работать не будут. Если же много
одинаковых чисел, то очень быстро найдётся решение и будет ``halt;``
(правда, строго доказывать, что сложность :math:`O(n^2)`, я не умею, но
вроде правдоподобно).

Классы :math:`P` и :math:`NP`. :math:`NP`-полнота
=================================================

Теория классов сложности :math:`P` и :math:`NP` имхо весьма интересна
сама по себе, а кроме того, нередко бывает полезна на практике, чего от
такой, на первый взгляд, весьма теоретизированной теории как-то и не
ожидаешь :). Кроме того, она приводит к, пожалуй, самой известной ещё
пока неразрешённой проблеме программирования: верно ли, что
:math:`P=NP`? Поэтому имхо полезно это все себе представлять, тем более
что в дальнейшем я, наверное, буду иногда ссылаться на этот материал. С
другой стороны, если вы не поймёте это с первого раза, тоже не страшно.
Может быть, вы не поймёте какую-то часть — попробуйте читать дальше,
вдруг вы поймёте дальнейшие идеи.

Материал, по-моему, весьма неплохо изложен в Кормене. Большинство
определений, которые я даю тут, не до конца строгие; более строго это,
наверное, изложено в Кормене.

Естественный параметр теста
---------------------------

Везде раньше у нас было довольно ясно, функцией от чего должна быть
сложность: везде под :math:`O`-обозначением стояла некое число
:math:`n`, которое, как подразумевалось, достаточно хорошо характеризует
размер теста. Но с другой стороны ясно, что в выборе :math:`n` как
параметра теста есть довольно широкий произвол; более того, могут быть
ситуации, когда далеко не очевидно, что именно будет служить хорошим
параметром теста; более того, иногда хочется ввести несколько таких
параметров сразу и т.п. Короче говоря, если мы хотим строить какую-то
более-менее универсальную теорию, классифицирующую алгоритмы по
сложности и т.п., то надо иметь какой-то более-менее универсальный,
естественный, способ выбора параметра теста, т.е. того, что будет стоять
под :math:`O`-обозначением, чтобы не думать каждый раз.

Таким весьма удобным параметром можно выбрать размер входного файла,
который везде далее будем обозначать :math:`L` (точнее, везде далее
:math:`L` будет обозначать размер входного файла), и сложность мы будем
мерить именно как функцию от :math:`L`. Это на первый взгляд несколько
неудобно, т.к. обычно в условии задачи стоит ограничение не на размер
файла, а на какое-нибудь :math:`N`, но, как мы увидим далее, в
большинстве разумных случаев класс алгоритма останется тем же, даже если
сложность мы запишем как функцию :math:`N`; как функцию :math:`L` мы её
будем записывать лишь затем, чтобы избавиться от этих слов «в
большинстве *разумных* случаев».

Полиномиальные алгоритмы и класс сложности :math:`P`
----------------------------------------------------

Про функцию :math:`f(m)` можно говорить, что она *полиномиальна* по
:math:`m`, если она есть :math:`O(m^k)` при некотором :math:`k`. В
частности, *полиномиальным* называется такой алгоритм, сложность
которого есть :math:`O(L^k)` при некотором фиксированном :math:`k`. Это
обозначает, что его сложность является полиномом (т.е. многочленом) от
:math:`L` (или ещё более быстрой функцией, например, логарифмом
:math:`L`).

Соответственно, класс задач, имеющих полиномиальное решение, называется
*классом* :math:`P` (слово «класс» очень часть используется как синоним
слова «множество»).

Если мы хотим расклассифицировать алгоритмы на «быстрые» и
«медленные», то в первом приближении логично полиномиальные алгоритмы
считать «быстрыми», а остальные — медленными. Логично: ведь, например,
разница во времени выполнения программы :math:`O(n)` и :math:`O(n^{10})`
при больших :math:`n` будет намного менее существенна, чем между
:math:`O(n^{10})` и :math:`O(2^n)`. Поэтому вся идеология классов
:math:`P` и :math:`NP` подразумевает в некотором смысле, что
полиномиальные алгоритмы — это быстрые алгоритмы и их можно реализовать
и дождаться результата работы, а остальные алгоритмы намного медленнее
и, грубо говоря, не всегда хочется ждать результата их работы. Ещё раз,
это скорее идеология, которая лежит под всеми нижеидущими определениями,
т.е. это просто объяснения, почему все определения даются именно так.

.. note::

    Заметьте, что, в соответствии с *нашим* определением,
    :math:`\log 
    n=O(n)` и т.п.

.. note::

    Замечу, что в *большинстве разумных случаев* размер входного
    файла есть полином (здесь именно полином, а не логарифм и т.п.!) от
    какого-нибудь параметра :math:`n`, указываемого в условии задачи
    (например, в задачах на граф размер входного файла есть обычно
    :math:`O(n^2)`, где :math:`n` — количество вершин в графе). В таких
    случаях полиномиальный алгоритм имеет также сложность :math:`O(n^{k'})`
    при некотором :math:`k'` (возможно, не равным :math:`k`), где :math:`n`
    — некоторый параметр теста из условия задачи, и потому вместо :math:`L`
    в определении полиномиальности можно использовать :math:`n`. Тем не
    менее, это не всегда так просто. Например, в задачах длинной арифметики
    алгоритм, работающий за :math:`O(n)`, где :math:`n` — одно из таких
    длинных чисел, нам, как правило, не интересен. Там логичнее использовать
    в качестве параметра теста *количество цифр* в числах (обозначим его
    :math:`m`), а не сами числа, т.е. фактически логарифмы чисел. В таком
    случае размер входного файла будет полиномиальным по :math:`m`, и
    :math:`m` полиномиально по :math:`L`, и полиномиальный по :math:`L`
    алгоритм будет полиномиальным и по :math:`m` и наоборот.

Сводимость задач
----------------

Пусть у нас есть две задачи, :math:`\mathcal{A}` и :math:`\mathcal{B}`.
Попробуем решить задачу :math:`\mathcal{A}` с помощью решения задачи
:math:`\mathcal{B}`. А именно, пусть у нас есть некоторое решение задачи
:math:`\mathcal{B}` — программа (exe-шник). Эту программу будем считать
«чёрным ящиком» в том смысле, что мы не будем лезть в её внутреннее
устройство, а будем её использовать лишь подавая некоторые данные на
вход и изучая, что же она выдаст на выходе. 

Попробуем с её
использованием написать программу решения задачи :math:`\mathcal{A}`, а
именно, попробуем написать программу решения задачи :math:`\mathcal{A}`
следующим образом: она будет читать входные данные, по ним каким-нибудь
(может быть, нетривиальным) образом формировать входной файл для задачи
:math:`\mathcal{B}`, потом запускать exe-шник-решение задачи
:math:`\mathcal{B}`, подсунув ему сформированный входной файл, потом
читать полученный выходной файл и формировать по нему свой выходной
файл. 

Т.е. основная наша задача — написать два алгоритма: как входной
файл к задаче :math:`\mathcal{A}` превратить во входной файл к задаче
:math:`\mathcal{B}`, и как выходной от задачи :math:`\mathcal{B}`
превратить в выходной файл от задачи :math:`\mathcal{A}` (естественно,
так, чтобы все это работало корректно, т.е. для любого допустимого
входного файла задачи :math:`\mathcal{A}` в итоге получался правильный
выходной файл задачи :math:`\mathcal{A}`; естественно, мы считаем, что
программа-решение задачи :math:`\mathcal{B}` работает корректно).

Пусть мы сумели придумать эти два алгоритма так, что *оба* они работают
за полиномиальное время от :math:`L_A` — размера входного файла задачи
:math:`A` (в частности, это обозначает, что сформированный входной файл
к задаче :math:`\mathcal{B}` будет иметь полиномиальный от :math:`L_A`
размер). Тогда говорят, что задача :math:`\mathcal{A}` *сводится* к
задаче :math:`\mathcal{B}`. (При этом важно только время работы
«сводящих» алгоритмов, время работы самой программы-решения
:math:`\mathcal{B}` не важно, не важно даже, умеем ли мы её решать).

.. note::

    Насколько я понимаю, это есть классическое определение
    сводимости задач. Можно поставить вопрос, можно ли разрешить запускать
    программу :math:`\mathcal{B}` несколько раз, и т.п., но для дальнейшего
    это нам будет не важно; мы будем придерживаться приведённого выше
    определения.

Пример: рассмотрим две задачи: задачу поиска в произвольном графе
гамильтонова цикла, т.е. цикла, проходящего по каждой вершине ровно один
раз, и так называемую «задачу коммивояжёра»: задачу поиска в *полном
взвешенном* графе минимального по весу гамильтонового цикла (очевидно,
что гамильтоновых циклов там полно: граф-то полный :) ). 

Тогда первая
задача сводится ко второй: действительно, по входному графу :math:`G`
задачи о гамильтоновом цикле сформируем входной граф к задаче
коммивояжёра следующим образом: вершин в нем будет столько же, (граф,
конечно же, будет полным), а ребро между вершинами будет иметь вес 0,
если оно присутствует в исходном графе :math:`G`, и вес 1, если
отсутствует. После этого запустим программу-решение задачи коммивояжёра
и, когда она найдёт гамильтонов цикл наименьшего веса, проверим, что его
вес равен 0. Если равен, то это — гамильтонов цикл в графе :math:`G`,
иначе в графе :math:`G` гамильтонового цикла не существует. (Если же
программа-решение задачи коммивояжёра не допускает нулевых рёбер
(вдруг), то сделаем веса равными 1 или 2 и будем проверять, что вес
найденного цикла равен :math:`N` — количеству вершин).


.. task::

    \ *Эйлеровым* циклом в графе называется цикл, который проходит
    по каждому ребру ровно один раз. Что вы можете сказать о задаче поиска
    минимального по весу эйлерова цикла в полном взвешенном графе? Сводится
    ли к ней задача поиска (какого-нибудь) эйлерова цикла в произвольном
    графе, и, если сводится, то как?
    |
    Конечно, искать эйлеров цикл
    минимального веса в полном взвешенном графе есть совершенно
    бессмысленное занятие — они там все одинакового веса :). Сведение одной
    задачи к другой аналогично сведению этих задач для гамильтонова цикла не
    пройдёт, но задачи все-таки сводятся друг к другу, просто потому, что
    обе задачи есть :math:`P`-задачи.
    |
    |

Заметим, что, в соответствии с этим определением, *любая*
:math:`P`-задача сводится к любой вообще задаче. Действительно, сводящий
алгоритм будет просто решать задачу :math:`\mathcal{A}`, не обращая
внимание на результат работы программы :math:`\mathcal{B}` (ну, при
желании, для выполнения формальностей определения, подсунув ей
какой-нибудь тест и не обращая внимания на результат её работы).

Ещё обратите внимание, что, если задача :math:`\mathcal{A}` сводится к
:math:`\mathcal{B}`, а :math:`\mathcal{B}` в свою очередь сводится к
:math:`\mathcal{C}`, то из этого следует, что :math:`\mathcal{A}`
сводится к :math:`\mathcal{C}` (это свойство называется
*транзитивностью*).

.. note::

    То, что задача :math:`\mathcal{A}` сводится к задаче
    :math:`\mathcal{B}`, обозначает, что задача :math:`\mathcal{A}` в
    некотором смысле *не сложнее* задачи :math:`\mathcal{B}`. Именно *не
    сложнее*, т.е. может быть и проще. Т.е., если вы свели задачу
    :math:`\mathcal{A}` к задаче :math:`\mathcal{B}`, то это обозначает, что
    любое решение задачи :math:`\mathcal{B}` вы можете применить к решению
    задачи :math:`\mathcal{A}`, но это *вовсе не обозначает*, что у задачи
    :math:`\mathcal{A}` нет других, может быть, ещё более лучших решений.
    Возможно, у задачи :math:`\mathcal{A}` есть какие-то особенности,
    которые можно использовать в более лёгком и простом алгоритме. Несколько
    примеров на это я приведу ниже, в предпоследнем параграфе этой темы.

.. note::

    А сейчас я приведу пример на несколько более общую идею: если вы смогли
    придумать, как задачу :math:`\mathcal{A}` решать с помощью задачи
    :math:`\mathcal{B}` (не обязательно *свели* :math:`\mathcal{A}` к
    :math:`\mathcal{B}` в смысле вышеприведённого определения: может быть,
    сведение у вас получилось неполиномиальным или, наоборот, очень быстрым,
    и вы этим гордитесь :) ), и применили самое лучшее решение задачи
    :math:`\mathcal{B}`, то это все равно не обозначает, что вы нашли лучшее
    решение задачи :math:`\mathcal{A}`. Этот пример не непосредственно на
    то, о чем я только что говорил: здесь все полиномиально и потому в
    рамках приведённого выше определения сводимости все тут благополучно
    сводится ко всему, но зато тут разные сложности.

    Итак, пример. Задача A про муравьёв с NEERC’2007. На плоскости даны
    :math:`N` белых и :math:`N` чёрных точек. Требуется каждую белую точку
    соединить отрезком с какой-нибудь чёрной так, чтобы каждая чёрная
    оказалась соединена ровно с одной белой и так, чтобы проведанные отрезки
    не пересекались. Никакие три точки не лежат на одной прямой. Официальное
    решение, насколько я понял, было следующее: рассмотрим немного другую
    задачу: соединить попарно (чёрную с белой, как и в оригинальной задаче)
    точки так, чтобы суммарная длина проведённых отрезков была минимальна.
    Несложно доказать, что в решении этой задачи отрезки не будут
    пересекаться, т.е. решение второй задачи есть одновременно и решение
    первой. Вторая же задача есть по сути частный случай так называемой
    задачи о назначениях — задачи поиска в полном взвешенном двудольном
    графе полного паросочетания минимального суммарного веса. Есть
    стандартное известное её решение, так называемый венгерский алгоритм. Он
    весьма нетривиален идейно, но реализуется за :math:`O(N^4)` с небольшой
    константой довольно легко, особенно если иметь навык его реализации; его
    можно реализовать и за :math:`O(N^3)`. Под стать такому положению дел
    было дано ограничение в задаче: :math:`N\leq 100`, что, наверное,
    позволяло пройти и венгерскому алгоритму за :math:`O(N^4)`. Но! На самом
    деле в этой задаче есть другое решение, которое идейно много проще
    венгерского алгоритма, и легко реализуется за :math:`O(N^3)`, а, если
    немного подумать, то и за :math:`O(N^2 \log N)`. Это решение намного
    проще, не требует знания никаких нетривиальных алгоритмов (типа
    венгерского), и пишется имхо намного легче, но *очень существенно*
    использует геометрическую природу задачи (т.е. использует геометрические
    идеи), и находит решение не обязательно с минимальной суммарной длиной
    (но обязательно несамопересекающееся). Поэтому, конечно, бессмысленно
    рассчитывать применить его к задаче о назначениях, что и неудивительно:
    мы же сводили нашу задачу к задаче о назначениях, а не в другую сторону.

    Мораль: если вы свели вашу задачу к какой-то другой (например,
    стандартной), это не значит, что вы нашли наилучшее решение. Может быть,
    у начальной задачи есть более крутое решение. Ещё мораль: знание
    стандартных алгоритмов не отменяет необходимость думать. Даже более
    того: думать уметь надо в первую очередь, а все, что я вам тут
    рассказываю, это просто подспорье, дополнительные инструменты. Но я
    надеюсь, что думать вы умеете и будете развивать это умение (в том числе
    и решая задания типа этого :) ), а вся теория — чтобы было в т.ч. к чему
    применять это умение.

    Если же вы, наоборот, свели (в общем смысле, т.е. не в смысле
    определения выше) другую (стандартную) задачу к своей, то вы можете
    что-то сказать про свою задачу (см. примере в параграфе про
    :math:`NP`-полноту): например, что ваша задача решается не быстрее, чем
    другая (если сведение достаточно быстрое). Правда, это не даст вам
    возможности написать алгоритм для вашей задачи. Конец примечания.



.. task::

    (Не имеет отношения к теории сложности) Попробуйте придумать и
    написать геометрическое решение задачи про муравьёв. Оно не требует
    знания ничего, кроме основных геометрических идей, даже выпуклую
    оболочку писать не надо уметь :)
    |
    Подсказка: идея «разделяй и
    властвуй». Попробуйте доказать, что всегда существует (хотя бы) одна
    чёрная и одна белая точка такие, что если провести через них прямую, то
    слева от неё будет поровну белых и чёрных точек (а тогда справа тоже
    будет поровну). Если нашли такую пару точек, то дальше решаем задачи
    отдельно слева и отдельно справа.
    |
    |

Задачи, рассматриваемые в теории про :math:`NP`
-----------------------------------------------

В дальнейшем мы будем рассматривать только задачи, на которые требуется
ответ вида «Да» или «Нет». Именно такие задачи рассматриваются в теории
про класс :math:`NP`. Например, задачи «Является ли данное число
:math:`N` простым», «Является ли данное число :math:`N` составным»
(заметьте, что это — две *разные* задачи, и дело тут не в случае
:math:`N=1`, а в том, что ответы на них диаметрально противоположны. Это
будет важно ниже), «Есть ли в данном графе гамильтонов цикл», «Есть ли в
данном графе эйлеров цикл» и т.п. (гамильтонов цикл — цикл, проходящий
по каждой вершине ровно один раз, эйлеров — проходящий по каждому ребру
ровно один раз).

Класс :math:`NP`
----------------

Рассмотрим задачу: проверить, является ли число :math:`N` составным.
Пусть вы решали эту задачу для некоторого :math:`N`, и пусть вы как-то
пришли к выводу, что :math:`N` действительно составное. Но доказать это,
чтобы другие люди вам поверили, может оказаться довольно сложно. Совсем
другое дело, если вы не только установили, что :math:`N` составное, но
ещё и нашли какой-то его делитель :math:`M`. Тогда кто угодно может
легко проверить, что :math:`N` действительно делится на :math:`M`
(разделив столбиком), тем самым убедившись, что :math:`N` действительно
составное. Эта проверка осуществляется весьма просто, и даже если кто-то
не хочет считать вручную, он всегда может написать программу на
компьютере, которая разделит :math:`N` на :math:`M`, причём эта
программа будет работать за полиномиальное время, т.е. «достаточно
быстро».

Ещё пример: задача поиска в графе гамильтонова цикла. Пусть вы почему-то
уверены, что в некотором графе есть гамильтонов цикл. Но убедить в этом
других людей вам может быть довольно сложно. Совсем другое дело, если вы
можете им продемонстрировать этот самый гамильтонов цикл: тогда кто
угодно легко проверит, что это действительно гамильтонов цикл, и
признает, что ответ на задачу — «Да».

Итак, общее определение класса :math:`NP`: задача относится к классу
:math:`NP` тогда и только тогда, когда для любого теста этой задачи, *на
который ответ «Да»*, существует некоторый подтверждающий пример (его в
дальнейшем будем называть *сертификатом*), который доказывает, что ответ
на задачу — «Да», который имеет полиномиальный размер от размера теста и
корректность которого можно проверить за полиномиальное время.

.. note::

    На самом деле то, что написано выше — весьма нестрогое определение.
    Строго говоря, определять надо так (может быть, весьма нетривиально
    понять, что определение, которое я даю ниже, соответствует тому, что мы
    хотим, но, если подумать, то становится ясно, что это так).

    Рассмотрим некоторую задачу. У неё есть множество возможных тестов.
    Пусть есть некоторое множество сертификатов, и есть полиномиальный
    алгоритм («алгоритм проверки сертификата»), который принимает на вход тест и
    сертификат и выдаёт либо Да либо Нет, причём удовлетворяет следующим
    условиям:

    - Если на тест ответ задачи Нет, то этот алгоритм на этом тесте 
      *при любом сертификате* выдаст Нет,
    - Если же на тест ответ задачи Да, то существует хотя бы один
      сертификат, на котором с этим тестом этот алгоритм выдаст Да, при
      этом этот сертификат имеет полиномиальный размер от размера теста.

    А на самом деле, наверное, ещё строже надо все определять через машину
    Тьюринга и т.п. Короче говоря, то, что я пишу тут — это все не очень
    строго, но основные идеи правильные.

Обратите внимание, что определение класса :math:`NP` несимметрично
относительно ответов Да и Нет; это будет весьма важно далее.

Примеры :math:`NP`-задач
------------------------

Две :math:`NP`-задачи уже были приведены выше: проверка, является ли
число составным и поиск гамильтонова цикла в графе.

Замечу, что весьма не очевидно, является ли задача проверки числа на
*простоту* :math:`NP`-задачей (попробуйте придумать сертификат для
ответа «Да, число простое». Доказывать надо именно случай ответа «Да», а
не «Нет». Я в своё время не смог). Тем не менее, задача проверки числа
на простоту на самом деле является вообще даже :math:`P`-задачей, и
существует соответствующий полиномиальный алгоритм (AKS primality test).

Давайте посмотрим ещё какие задачи являются :math:`NP`-задачами.
Например, задача коммивояжёра…Нет. Стоп. Она не есть :math:`NP`-задача
просто потому, что она не является Да/Нет-задачей. Но для задач
оптимизации (например, задачи коммивояжёра) есть стандартный способ
перехода к Да/Нет-задачам: а именно, в данном случае вместо просто
задачи коммивояжёра, т.е. задачи «по данному полному взвешенному графу
найти в нем гамильтонов цикл минимального веса», рассмотрим задачу «по
данному полному взвешенному графу и числу :math:`w` проверить, есть ли в
этом графе гамильтонов цикл веса не более :math:`w`\ ». Последняя задача
является Да/Нет-задачей и, очевидно, является :math:`NP`-задачей,
сертификатом является сам такой цикл.

Совершенно аналогично можно рассмотреть ещё три задачи: задачу о
максимальной клике (найти в данном графе максимальный полный подграф,
т.е. максимальное множество вершин, в котором каждые две вершины связана
друг с другом ребром), задачу о максимальном независимом множестве
(найти в данном графе наибольший *пустой* подграф, т.е. наибольшее (по
количеству) множество вершин, никакие две из которых не связаны ребром)
и задачу о минимальном контролирующем множестве (найти в данном графе
минимальное по количеству множество вершин такое, что у каждого ребра
хотя бы один его конец лежит в этом множестве: т.е. будем говорить, что
вершина контролирует все ребра, которые из неё выходят. Надо найти
минимальный набор вершин, которые (в совокупности) контролируют все
ребра).



.. task::

    Докажите, что все эти три задачи сводятся друг к другу.
    
    |
    Подсказка: если инвертировать граф (т.е. где было ребро — удалить, а
    где не было — добавить), то клика станет независимым множеством и
    наоборот. Ещё подсказка: если есть некоторое независимое множество, то
    оставшиеся вершины образуют контролирующее множество, и наоборот.
    |
    |

Ни одна из этих задач не является Да/Нет-задачей, но у всех из них можно
рассмотреть «парные» к ним Да/Нет-задачи, которые спрашивают, существует
ли объект с количеством вершин больше/меньше данного :math:`k` (больше
или меньше, очевидно, зависит от того, ищем мы минимум или максимум), и
все полученные Да/Нет-задачи будут :math:`NP`-задачами.

Заметьте, что все такие Да/Нет задачи, полученные из некоторых задач
оптимизации, сводятся назад к задачам оптимизации, поэтому они не
сложнее задач оптимизации (но не обязательно наоборот!)

Далее, заметим, что *все* :math:`P`-задачи являются :math:`NP`-задачами.
Действительно, алгоритм проверки сертификата может просто-напросто
*игнорировать* сертификат и просто решать задачу, благо она :math:`P`, и
потому вполне можно её решить за полиномиальнео время. (Проще говоря,
если вы хотите кого-то убедить в том, что на некотором тесте в
:math:`P`-задаче ответ Да, то и сертификата никакого не надо: кто угодно
может сам решить эту задачу и проверить, что ответ Да). Поэтому точно
можно сказать, что :math:`NP` есть надмножество \ :math:`P`.

Пример не-\ :math:`NP`-задачи
-----------------------------

С первого взгляда может показаться, что все задачи очевидно :math:`NP`.
Тем не менее это не так, по крайней мере есть задачи, про которые далеко
не очевидно, что они :math:`NP`. Например, уже упоминавшаяся задача
проверки числа на простоту (тем не менее, *далеко не очевидно* и — в
данном случае — совершенно неверно, что она не-\ :math:`NP`, на самом
деле она даже :math:`P`). Вообще, можно взять какую-нибудь
:math:`NP`-задачу и поменять местами ответы «Да» и «Нет» (например, из
задачи поиска гамильтоновго цикла получится задача «верно ли, что в
данном графе *нет* гамильтонового цикла»). Как правило, будет далеко не
очевидно, является ли полученная задача :math:`NP`-задачей. Утверждается
(но я доказывать не умею :) ) что задача проверить, верно ли, что данный
цикл есть наидлиннейший среди простых циклов, *точно* не является
:math:`NP`-задачей (хотя задача проверить, есть ли цикл длиннее данного,
очевидно является).

:math:`NP`-полнота
------------------

Теперь определение :math:`NP`-полноты задач очень простое:
:math:`NP`-задача называется :math:`NP`\ *-полной*, если к ней сводится
*любая* :math:`NP`-задача. Определение простое, но страшное: совершенно
не ясно, как доказывать, что *любую* :math:`NP`-задачу можно свести к
нашей. Но на самом деле все на так плохо: достаточно найти одну задачу
:math:`\mathcal{A}`, к которой сводится любая задача из :math:`NP`,
тогда для доказательства :math:`NP`-полноты любой другой задачи
:math:`\mathcal{B}`, в силу транзитивности сведения, достаточно будет
доказать, что задача :math:`\mathcal{A}` сводится к :math:`\mathcal{B}`.
Более того, чтобы доказать, что некоторая задача является
:math:`NP`-полной, очевидно, к ней достаточно свести любую другую
задачу, про которую уже доказано, что она :math:`NP`-полна. Но, обратите
внимание, именно некоторую :math:`NP`-полную задачу надо свести *к*
нашей, а не наоборот. Если, наоборот, вы какую-то задачу свели к
:math:`NP`-полной, это ещё ничего не значит.

Базовая идея определения такая: мы хотим одним махом научиться решать
сразу все :math:`NP` за полиномиальное время. Если есть задача,
к которой сводятся все :math:`NP`\ -задачи, то как только мы ее научимся
быстро решать, то тут же сразу мы научимся *все* :math:`NP`\ -задачи решать.

Пример такой задачи :math:`\mathcal{A}` и *идей* доказательства
сводимости любой :math:`NP`-задачи к ней можно посмотреть в Кормене; я
очень рекомендую это сделать хотя бы потому, что идея весьма интересная,
хотя практического приложения у неё я не вижу. Здесь я все-таки
приводить это не буду.

Примеры :math:`NP`-полных задач: задача поиска гамильтонова цикла;
Да/Нет-задачи, парные к задачам о максимальной клике, максимальное
независимом множестве, минимальном контролирующем множестве, к задаче
коммивояжёра. Более полный список опять-таки можно посмотреть в Кормене.

Проблема :math:`P=NP` и вообще зачем все это нужно
--------------------------------------------------

Одной из наиболее известных и, насколько я понимаю, до сих пор не
решённых проблем (теоретического, что ли) программирования является
проблема верно ли, что :math:`P=NP`, т.е. что множества задач 
:math:`P` и :math:`NP` совпадают, т.е. верно ли, что у каждой
:math:`NP` задачи есть полиномиальное решение. Очевидно, что для
доказательства того, что :math:`P=NP`, достаточно найти полиномиальное
решение для любой :math:`NP`-полной задачи, т.к. тогда все остальные
:math:`NP`-задачи будут тоже иметь полиномиальное решение. Однако, люди
давно уже бьются над решением :math:`NP`-полных задач, и пока что-то
ничего у них не получается (в смысле, полиномиальное решение не
находится). Поэтому сейчас уже мало кто верит в то, что :math:`P=NP`,
хотя строго доказать то, что :math:`P\neq NP`, пока тоже никто не смог.

Практический вывод отсюда такой: если вам на олимпиаде попалась
:math:`NP`-полная задача, или вы смогли доказать, что данная вам задача
является :math:`NP`-полной (именно сведя некоторую :math:`NP`-полную
задачу к вашей), то не стоит пытаться искать для неё полиномиальное
решение. Как где-то было метко сказано (в ОНЗИ, что ли), если вы на
олимпиаде нашли полиномиальное решение :math:`NP`-полной задачи, то
можете смело вставать и уходить с олимпиады: вы сделали открытие намного
более важное, чем победы в любых олимпиадах :). Правда, в этом случае
намного более вероятно то, что ваш алгоритм просто неверен.

В частности, все вышесказанное обозначает, что, если вы доказали, что
некоторая задача является :math:`NP`-полной, то можете не искать
полиномиальное решение и смело писать что-нибудь неполиномиальное: у
жюри наверняка тоже нет полиномиального решения этой задачи, и потому
жюри тоже наверняка решало чем-нибудь неполиномиальным. Только внимание!
Неполиномиальное решение — это *вовсе не обязательно* перебор. Есть по
крайней мере несколько крутых идей, которые позволяют написать хоть и
неполиномиальное решение, но решение, которое будет работать быстрее
перебора (например, динамика по профилю и динамика по подмножествам), и
которые намного приятнее в написании (не надо придумывать кучу эвристик
и отсечений и т.д.; а кроме того, у них вы сможете оценить время работы
намного точнее, чем у перебора — про это расскажу (наверное) позже,
когда буду собственно про эти динамики говорить).

.. note::

    Правда, иногда встречаются подлости, когда жюри, например, не
    заметило, что задача :math:`NP`-полна, и потому придумало некоторый
    полиномиальный алгоритм, который на самом деле работает не всегда, но
    жюри этого не заметило, и тесты подобрало соответствующие. В таком
    случае, конечно, неполиномиальные решения могут не пройти часть тестов.
    Но все равно это — вина жюри, а не ваша :)

Таким образом, основное применение теории :math:`NP`-полноты в
олимпиадном программировании, пожалуй, это доказательство того, что
задача, скорее всего, не решается за полиномиальное время.

:math:`NP`-трудные задачи
-------------------------

Вернёмся опять к задачам на оптимизацию. Очевидно, что для задачи
коммивояжёра тоже не стоит искать полиномиальное решение, хоть она и не
является :math:`NP`-полной задачей. Действительно, если бы у задачи
коммивояжёра было бы полиномиальное решение, то оно же было бы и у
соответствующей ей Да/Нет задаче, которая является :math:`NP`-полной.

Определение: не-\ :math:`NP` задача называется :math:`NP`\ *-трудной*,
если к ней сводится любая :math:`NP` задача. (В частности, задача будет
:math:`NP`-трудной, если к ней сводится какая-нибудь :math:`NP`-полная
задача. Например, рассмотренные выше задачи об оптимизации: к ним
сводятся соответствующие :math:`NP`-полные Да/Нет-задачи)

Таким образом, задача коммивояжёра, задача о максимальной клике и т.д.
являются :math:`NP`-трудными. Про :math:`NP`-трудные задачи верно все
то, что сказано в предыдущем параграфе (т.е. если на олимпиаде вам
попалась :math:`NP`-трудная задача, то …). Нередко термины
:math:`NP`-полная и :math:`NP`-трудная задачи не различают и про оба
типа задач говорят, что они :math:`NP`-полные.

Приведу ещё пример: задача найти в данном графе самый длинный простой
цикл (вершинно-простой, т.е. в котором вершины не повторяются). Она
:math:`NP`-трудна, т.к. к ней очевидно сводится задача о гамильтоновом
цикле. Но с ходу не очевидно, что парная к ней Да/Нет-задача (верно ли,
что в данном графе есть простой цикл длины как минимум :math:`k`),
является :math:`NP`-полной (хотя, конечно, является — к ней тоже
сводится задача о гамильтоновом цикле).

Дополнительные замечания
------------------------

Замечание 1. Ещё раз подчёркиваю, что для того, чтобы доказать, что
некоторая задача :math:`\mathcal{A}` является :math:`NP`-полной, надо
какую-нибудь другую задачу :math:`\mathcal{B}`, про которую уже
известно, что она :math:`NP`-полная, свести к :math:`\mathcal{A}`, а не,
как может показаться с первого взгляда, наоборот: свести нашу задачу
:math:`\mathcal{A}` к :math:`NP`-полной :math:`\mathcal{B}`. В
частности, если ваша задача является *частным случаем*
:math:`NP`-полной, то это ничего не значит. Например, задачи поиска
максимального независимого множества и минимального контролирующего
множества для случая произвольного графа являются :math:`NP`-полными, а,
например, для случая двудольного графа имеют довольно простое
полиномиальное решение. Аналогично, задача о гамильтоновом цикле в
произвольном графе является :math:`NP`-полной, но, если я наложу на граф
какие-нибудь ограничения, то будет совершенно неочевидно, что полученная
задача будет :math:`NP`-полной. Например, задача о гамильтоновом цикле в
двудольном графе: сразу не очевидно, :math:`NP`-полна она или нет, или
вдруг она даже имеет полиномиальное решение. Аналогично, например, если
рассматривать только планарные графы. С ходу совершенно непонятно, чем
планарность может помочь в поиске гамильтонова цикла, но кто знает…

Замечание 2. Рассмотрим такую задачу: дан набор чисел и ещё одно число.
Требуется проверить, есть ли это число среди данного набора чисел.
Очевидно линейное, т.е. полиномиальное, решение. Вопрос: является ли эта
задача :math:`NP`-полной? Правильный ответ: *до сих пор неизвестно*.
Действительно, если :math:`P\neq NP`, то тогда :math:`NP`-полные задачи
не могут иметь полиномиальных решений, и поэтому эта задача, конечно же,
не является :math:`NP`-полной. Но если вдруг окажется, что :math:`P=NP`,
то тогда *любая* :math:`P`-задача является :math:`NP`-полной, т.к., как
мы выяснили раньше, любая :math:`P`-задача сводится к любой. Это,
конечно, своеобразная тонкость, как мне кто-то в ЛКШ сказал, «ну
закладываться на такие случаи — это уж слишком», но нетривиальная
тонкость.

Замечание 3. Большинство рассмотренных выше задач были задачами на
графы. Но это, конечно, не обозначает, что других (не-графовых)
:math:`P`, :math:`NP` и :math:`NP`-полных задач нет.

Перечень задач
--------------

Приведу тут список задач, которые обсуждались в этой части, с
комментариями по ним — чтобы вы не запутались.

-  Задачи длинной арифметики (сложение и т.п.) — класс :math:`P`,
   конечно же;

-  Задача о гамильтоновом цикле в произвольном графе — :math:`NP`-полна;

-  Задача коммивояжёра — :math:`NP`-трудна;

-  Задача об эйлеровом цикле — класс :math:`P`;

-  Задача A про муравьёв с полуфинала’2007 — класс :math:`P`, конечно
   же;

-  Является ли данное число простым? — далеко не очевидно, что
   :math:`NP`, но на самом деле, даже класс :math:`P` (а, следовательно,
   и :math:`NP`);

-  Является ли данное число составным? — очевидно, что :math:`NP`, но на
   самом деле даже :math:`P`;

-  Задача о максимальной клике, максимальном независимом множестве,
   минимальном контролирующем множестве в произвольном графе —
   :math:`NP`-трудны;

-  соответствующие им Да/Нет задачи :math:`NP`-сложны;

-  Задача о максимальной клике, максимальном независимом множестве,
   минимальном контролирующем множестве в двудольном графе — :math:`P`;

-  Задача проверить, верно ли, что данный цикл есть наидлиннейший среди
   простых циклов — видимо, не является даже :math:`NP` (но я не знаю,
   является ли она :math:`NP`-трудной);

-  Задача проверить, есть ли в графе цикл длиннее данного — :math:`NP`;

-  Найти в данном графе самый длинный вершинно-простой цикл —
   :math:`NP`-трудна;



.. task::
    :name: Дополнительное задание

    (если делать нечего): Напишите
    переборные решения всех, особенно :math:`NP`-трудных, обсуждавшихся выше
    задач.
    |
    |
    |


.. include:: tasks.rst
.. include:: suggests.rst
   
