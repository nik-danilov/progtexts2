Виды задач на ДП
================

В предыдущих разделах я описывал, в первую очередь, общие теоретические
основы ДП, иллюстрируя их лишь иногда примерами. Здесь я приведу примеры
практического применения ДП в задачах, показывая, какие бывают
подзадачи. По ходу я также буду показывать разные приёмы, которые, как
мне кажется, могут быть полезны в задачах на ДП.

Линейное ДП
-----------

Ну, это довольно просто. Вы для каждого :math:`i` считаете некоторую
величину, используя ранее насчитанные ответы при меньших :math:`i`.
Пример — задача про 01-последовательности, которую мы уже обсуждали.

Отмечу тут только ещё одну особенность, которая на самом деле относится
ко всем видам ДП. Бывают два случая: либо, как в задаче про
01-последовательности, вам просто дано :math:`N` и просят посчитать
:math:`ans[N]`, который ни от чего, кроме :math:`N`, не зависит. А
бывает, как в задаче про наибольшую возрастающую последовательность, что
вам дают массив :math:`a`, обычно длины :math:`N`, и ответ существенно
зависит от этого массива — короче говоря, вам или дают только размеры,
или ещё какие-то данные линейного (квадратичного и т.п.) размера по
:math:`N` (:math:`M` и т.д.). В последнем случае, как мне кажется, может
возникнуть вопрос: а как мы будем считать :math:`ans[i]` для
промежуточных :math:`i`? В большинстве случаев ясно, как: :math:`ans[i]`
будет ответом для первых :math:`i` элементов массива :math:`a`. Т.е.
подзадача от полной задачи будет отличаться просто тем, что выкинули
несколько последних элементов массива :math:`a`, и все. Могут, конечно,
быть особые случаи, когда это не так, но это уж слишком :).

.. task::

    `Задача 7 «Числа» с региональной олимпиады — 2009 <https://algoprog.ru/material/p1211>`_

    Решая задачу по информатике, Вова в очередной раз допустил ошибку. Он снова вывел в выходной файл числа, забыв разделить их пробелами. Увидев полученный результат, Вова сначала огорчился, а потом задумался над следующим вопросом: сколько существует различных последовательностей неотрицательных целых чисел, таких что, если выписать их без пробелов, то получится тот же результат, что и у него. Он вспомнил также, что его программа смогла вывести не произвольные числа, а только те, что не превосходят C и не имеют ведущих нулей.

    Чтобы ответить на поставленный вопрос, Вова решил написать программу, которая позволит ему найти число различных последовательностей неотрицательных целых чисел, в каждой из которых любое число не превосходит C. Он понимал, что такое число могло быть достаточно большим, поэтому ограничился поиском только последних k цифр этого числа.

    Требуется написать программу, которая покажет Вове, как можно правильно решить поставленную им задачу.

    |
    В принципе, задача была бы совсем простая, если бы не требование
    про ведущие нули. Но, раз ведущие нули запрещены, то приходится
    немного повозиться. В принципе, можно так все и сделать, но упрощает
    реализацию либо использование динамики с просмотром вперёд, либо
    «обращение» динамики, как в задаче :ref:`про Буратино <buratino>`.
    |
    Пожалуй, приведу целых два с половиной варианта решения.

    Во-первых, можно поступить совершенно стандартно. Пусть :math:`ans[i]`
    будет ответ для строки, состоящей из первых :math:`i` символов (цифр)
    входной строки. Как связать :math:`ans[i]` с ответами для меньших
    :math:`i`? Ну очевидно: посмотрим, на что мог заканчиваться вывод
    программы, соответствующий первым :math:`i` цифрам? Ясно, что на одно-,
    двух-, или т.д., значное число. Каждый из этих вариантов имеет место
    только если 1) соответствующее число не начинается на ноль и 2)
    соответствующее число не превосходит максимального возможного числа,
    :math:`C`. Второе условие заодно, очевидно, даёт ещё и ограничение на
    значность последнего числа. Итого сложность :math:`O(nl)`, где :math:`l`
    — число цифр в :math:`C`. Реализация не очень сложна, надо только
    проверять ведущий ноль и т.д. Или можно написать ДП с просмотром вперёд,
    тогда не надо будет проверять ведущий ноль у каждого числа, а только
    один раз для каждого :math:`i`.

    Но второй вариант — «обратить» динамику. Пусть :math:`ans[i]` обозначает
    ответ для строки, образованной последними :math:`n-i+1` символами
    (цифрами) входной строки (т.е. с :math:`i`-ой цифры до последней). Тогда
    переберём, с чего может начинаться этот вывод. Если :math:`s[i]=0`
    (:math:`s` — входная строка), то только с нуля (однозначное число ’0’
    допустимо в выводе, судя по условию), и тогда :math:`ans[i]=ans[i+1]`,
    иначе может начинаться с одно-, двух- и т.д. значных чисел, до тех пор,
    пока это число не превзойдёт :math:`C`. Соответственно будет
    :math:`ans[i]=ans[i+1]+ans[i+2]+\dots`.

    В обоих решениях надо отдельно подумать про инициализацию динамики; как
    всегда, вам помогут нулевые элементы. И, конечно, все вычисления делаете
    по модулю :math:`10^k`.

    И «второй с половиной» вариант — это фактически как дойти до второго
    решения, не зная динамики вообще. Если бы вы писали тут перебор, то
    наверняка у вас была бы функция типа :math:`find(i)`, которая перебирает
    все способы вывести цифры с :math:`i`-ой по последнюю. Она бы запускала
    :math:`find(i+1)`, :math:`find(i+2)` и т.д. и суммировала бы результаты.
    (Точнее, можно считать решения путём команды ``inc(ans)`` в процедуре
    check, а можно написать так, чтобы :math:`find` возвращала количество
    решений. Мы будем считать, что :math:`find` именно возвращает количество
    решений). Тогда, заметив перекрытие подзадач, можно легко додуматься до
    запоминания, и получить рекурсию с запоминанием результата.

    Вот результат:

    ::

        function ch(m:word):int64;
        var r:int64;
            i:word;
            chis:longint;
            o:word;
        begin
        o:=m;
        if b[m]<>-1 then begin
        ch:=b[m];
        exit;
        end;
        if m=n then begin
        ch:=1;
        exit;
        end;
        if a[m+1]=0 then begin
        ch:=ch(m+1);
        exit;
        end;
        r:=0;
        chis:=0;
        while (m<n) do begin
            inc(m);
            chis:=chis*10+a[m];
            if (chis>c) then break;
            r:=(r+ch(m)) mod kvc;
        end;
        ch:=r;
        b[o]:=r;
        end;

    Реализация немного нешаблонная и нагруженная, но вроде все просто и
    легко понимается.

    Параметр функции тут — сколько цифр с начала входной строки мы
    отбрасываем (т.е. сколько мы уже вывели), т.е. в отличие от приведённого
    выше варианта, :math:`m=i-1`. Соответственно, «нулевой элемент» —
    :math:`m=n`, тогда ответ — один. «Количество цифр» :math:`kvc=10^k`.
    |

Многомерное ДП
--------------

Ничуть не сложнее предыдущего, просто здесь для каждого :math:`i` и
:math:`j` вычисляете :math:`ans[i,j]`, или аналогично с тремя и более
параметрами; как правило, здесь :math:`i`, :math:`j` и т.д.
действительно играют роль в том или ином смысле координат: или напрямую,
как в задачах про черепашку, или в некотором другом, но тоже простом
смысле. Итак, две таких задачи мы уже разобрали, обсудим ещё
классическую задачу на многомерное ДП — задачу про наибольшую общую
подпоследовательность.

Итак, даны две строки, :math:`s_1` и :math:`s_2`. Требуется из каждой из
них вычеркнуть несколько (возможно, ноль) символов так, чтобы получились
одинаковые строки, причём получившиеся строки должны иметь максимальную
длину. Пример: если есть две последовательности: ``acbaaba`` и
``bcacb``, то ответом будет ``bab`` или ``acb`` или ``cab`` и т.п.:
любую из этих строк можно получить вычёркиванием нескольких символов из
обеих данных строк, но никакая более длинная строка таким свойством не
обладает.

Как решать эту задачу? Первая основная идея ДП: *придумаем себе
подзадачи*. Здесь в качестве подзадач естественно рассмотреть следующие:
для каждого :math:`i` и :math:`j` посчитаем :math:`ans[i,j]` — длину
наибольшей общей подпоследовательности [1]_ у первых :math:`i` символов
первой строки и у первых :math:`j` символов второй строки. Например, в
приведённом выше примере :math:`ans[4,3]=2`: это длина наибольшей общей
подпоследовательности у строк ``acba`` и ``bca`` (эта общая
подпоследовательность — ``ba`` или ``ca``).

Как найти ответ на подзадачу? Вторая основная идея ДП:
*посмотрим, на что может кончаться* решение. Имея ввиду, что нам надо
свести нашу подзадачу к более мелким, понятно, что есть два варианта.
Если :math:`i`-ая буква первой строки не равна :math:`j`-ой букве
второй, то ясно, что хотя бы одну из них (а, может быть, и две) мы
должны вычеркнуть, и дальше решать задачу, когда одна из строк стала
короче. Тогда :math:`ans[i,j]=\max(ans[i-1,j],ans[i,j-1],ans[i-1,j-1])`.
Если же эти две буквы совпадают, то ясно, что мы либо не вычёркиваем их,
и тогда решение будет решением для :math:`(i-1,j-1)`, к которому
приписана одна буква, либо хотя бы одну из них вычёркиваем — короче
говоря,
:math:`ans[i,j]=\max(ans[i-1,j-1]+1,ans[i-1,j],ans[i,j-1],ans[i-1,j-1])`.
На самом деле, если подумать, то можно упростить эти соотношения и
окончательно получить

.. math::

   ans[i,j]=\left\{\begin{array}{ll}
   \max(ans[i-1,j],ans[i,j-1])\qquad&{если\ }s_1[i]\neq s_2[j]\\
   ans[i-1,j-1]+1\qquad&{если\ }s_1[i]=s_2[j]
   \end{array}\right.


.. _LCS:proof:

.. task::

    Докажите эти соотношения (они не очевидны!)
    |
    Конечно, тут
    все просто, но надо бы это облечь в строгую форму. С ходу сказать, что
    это очевидно, нельзя. Например, почему, если :math:`s_1[i]=s_2[j]`, то
    мы оставляем обе буквы? Почему не может быть так, что одну выкидываем?
    
    |
    Итак, возможны два варианта. Пусть :math:`s_1[i]=s_2[j]`. Рассмотрим
    оптимальное решение для подзадачи :math:`(i,j)`. Если оно подразумевает
    вычёркивание как :math:`s_1[i]`, так и :math:`s_2[j]`, то очевидно, что
    оно не оптимальное: не будем их вычёркивать — получим тоже общую
    подпоследовательность, но длиннее. Значит, хотя бы она из двух букв не
    вычёркивается. Пусть это :math:`s_1[i]`. Но тогда последняя
    невычеркнутая буква в :math:`s_2` — пусть это буква :math:`s_2[j']` —
    должна совпадать с :math:`s_1[i]` (а иначе после вычёркивания получаются
    разные строки). Но тогда вычеркнем :math:`s_2[j']`, но не будем
    вычёркивать :math:`s_2[j]` — получим оптимальное решение, в котором как
    :math:`s_1[i]`, так и :math:`s_2[j]` сохранены. Значит, существует
    оптимальное решение, где обе буквы сохранены. Но тогда несложно
    показать, что наибольшая общая подпоследовательность будет ответом для
    :math:`(i-1,j-1)`, к которому приписан символ :math:`s_1[i]`, т.е.
    :math:`ans[i,j]=ans[i-1,j-1]+1`.
    
    Если же :math:`s_1[i]\neq s_2[j]`, то ясно, что хотя бы одну из них надо
    вычеркнуть. Если вычёркиваем :math:`s_1[i]`, то ответ будет
    :math:`ans[i-1,j]` (независимо от того, вычёркиваем ещё и :math:`s_2[j]`
    или нет — вопрос о необходимости вычёркивания :math:`s_2[j]` решится уже
    в задаче :math:`(i-1,j)`, а в :math:`(i,j)` мы воспользуемся готовым
    решением). Если же вычёркиваем :math:`s_2[j]`, то ответ будет
    :math:`ans[i,j-1]` (независимо от того, вычёркиваем ещё и :math:`s_1[i]`
    или нет!). Т.е. в общем случае
    :math:`ans[i,j]=\max(ans[i-1,j],ans[i,j-1])`. Ещё раз обратите внимание,
    как мы избавились от варианта «вычеркнуть обе и взять
    :math:`ans[i-1,j-1]`\ »: это та же идея, что и в задаче
    :ref:`про неограниченное количество монет <multi\_coins>`, и в конце раздела :ref:`subsequence`.
    
    |




Далее все ясно. В двойном цикле вычисляем значения, все понятно. Отмечу,
что это как раз и есть многомерное ДП: можно легко записать одну строчку
по вертикали, вторую по горизонтали и писать :math:`ans` матрицей между
ними, как показано в таблице ниже.

+-----+-----+-----+-----+-----+-----+
|     | b   | c   | a   | c   | b   |
+-----+-----+-----+-----+-----+-----+
| a   | 0   | 0   | 1   | 1   | 1   |
+-----+-----+-----+-----+-----+-----+
| c   | 0   | 1   | 1   | 2   | 2   |
+-----+-----+-----+-----+-----+-----+
| b   | 1   | 1   | 1   | 2   | 3   |
+-----+-----+-----+-----+-----+-----+
| a   | 1   | 1   | 2   | 2   | 3   |
+-----+-----+-----+-----+-----+-----+
| a   | 1   | 1   | 2   | 2   | 3   |
+-----+-----+-----+-----+-----+-----+
| b   | 1   | 1   | 2   | 2   | 3   |
+-----+-----+-----+-----+-----+-----+
| a   | 1   | 1   | 2   | 2   | 3   |
+-----+-----+-----+-----+-----+-----+


Да, ещё важный момент. «База» динамики. Несложно видеть, что в
соответствии с нашим рекуррентным соотношением особыми случаями тут
являются :math:`i=1` или :math:`j=1`. Если подумать, то полезно ввести
нулевые строку и столбец с :math:`ans[0,j]=ans[i,0]=0`, и все будет
работать.



.. task::

    Напишите процедуру :math:`out` для вывода решения в этой
    задаче.
    |
    |
    Вроде ничего сложного, все совсем по стандартному
    шаблону.
    
    ::
    
        procedure out(i,j)
        begin
        if (i=0)or(j=0) then exit;
        if s1[i]=s2[j] then begin
           out(i-1,j-1);
           write(s1[i]);
        end else begin
            if ans[i-1,j]>ans[i,j-1] then
               out(i-1,j)
            else out(i,j-1);
        end;
        end;
    
    
    |


.. _LCS:FirstLex:


.. task::

    Подумайте над тем, как тут выводить первое в
    лексикографическом порядке решение. По-моему, это не очень тривиально.
    
    |
    Хочется сразу обратить динамику, чтобы выводить решение с начала в
    конец. Но это не сильно помогает. В случае :math:`s_1[i]\neq s_2[j]`
    нужно будет выбрать, какой из двух вариантов выводить, и если они
    одинаковой длины, то придётся сравнивать их лексикографически, что очень
    нетривиально: мало того, что сложно понять, на какую букву начинается
    решение, так ведь ещё эти буквы могут оказаться одинаковыми, и надо
    будет смотреть вторую букву и т.д.
    
    В общем, я не знаю, как тут по стандартному шаблону выводить первое в
    лексикографическом порядке решение, поэтому придётся привлекать тяжёлую
    артиллерию — учитывать необходимость вывода лексикографически первого
    решения прямо в динамике. Подумайте. Кстати, сложность решения тут
    повысится до :math:`O(N^3)`, и я не знаю, как её улучшить.
    |
    Итак,
    главная идея — раз не получается простыми методами, то подойдём к задаче
    серьёзно. А именно, давайте для каждого :math:`(i,j)` найдём не просто
    *длину* решения, но и само первое в лексикографическом порядке решение!
    Т.е. :math:`ans[i,j]` будет хранить нужное нам решение. Тогда
    рекуррентное соотношение будет следующее:
    
    .. math::
    
        ans[i,j]=\left\{\begin{array}{ll}
        ans[i-1,j-1]+s_1[i],\quad&s_1[i]=s_2[j],\\
        ans[i-1,j],\qquad&s_1[i]\neq s_2[j]\text{ и }ans[i-1,j]\text{ «лучше» }ans[i,j-1],\\
        ans[i,j-1],\qquad&s_1[i]\neq s_2[j]\text{ и }ans[i,j-1]\text{ «лучше» }ans[i-1,j],\\
        \end{array}\right.
    
    здесь под «\ :math:`a` лучше :math:`b`\ » понимается «строка :math:`a`
    длиннее строки :math:`b` или у них одинаковые длины, но :math:`a` идёт
    раньше в лексикографическом порядке, чем :math:`b`\ ». Короче, выбираем
    более длинное решение, а при равных длинах — то, что идёт
    лексикографически раньше.
    
    Символ ’\ :math:`+`\ ’ в первом варианте обозначает, конечно,
    конкатенацию строк (т.е. к строке :math:`ans[i-1,j-1]` приписываем
    символ :math:`s_1[i]`).
    
    Сложность решения стала :math:`O(N^3)` не только из-за необходимости
    копировать строки (от чего, наверное, можно было бы и избавиться), но
    ещё и из-за необходимости сравнивать строки, от чего, я думаю,
    избавиться не так просто.
    
    Кстати, обратите внимание, что тут вполне все получилось и без
    «обращения» динамики. Можно было и обратить, решение осталось бы
    аналогичным.
    
    Я надеюсь, что стало понятна не только решение этой задачи, но и общая
    идея, что делать в том случае, когда простыми способами вывести
    требуемое решение не получается. В таких случаях надо просто расширить
    динамику и уже там вычислять не только главный параметр, по которому
    идёт оптимизации (длину строки), но и остальные параметры.
    
    Да, я не предлагаю всегда в подобных ситуациях хранить сразу решение,
    нет. Только минимальную информацию, необходимую для выбора нужного
    решения в процедура :math:`out`. Например, потребовали бы здесь выводить
    решение с минимально возможным количеством букв ``a`` — мы бы
    легко это сделали, просто в :math:`ans` хранили бы длину решения, а в
    :math:`mina` — минимальное количество букв ``a`` в правильном
    решении. Решение потом восстановили бы стандартным способом с помощью
    процедуры :math:`out`. Кстати, работало бы за :math:`O(N^2)`.
    
    |



Отмечу ещё один момент, общий вообще для ДП. Нередко, получив задачу,
похожую на другую, знакомую вам, задачу на ДП, хочется просто свести
одну к другой, т.е. придумать решение первой задачи в виде «по входным
данным для первой задачи получим какие-то входные данные для второй,
потом решим вторую, потом по решению второй найдём решение для первой».

Например, есть задача про наибольший подпалиндром, которую мы подробно
обсудим в следующем разделе. Кратко: дана строка, требуется вычеркнуть
из неё минимальное количество букв так, чтобы получился палиндром —
строка, читающаяся одинаково как слева направо, так и справа налево.
Правильное и простое решение этой задачи мы обсудим чуть позже, а пока
скажу, что может захотеться свести её к только что разобранной нами
задаче о наибольшей подпоследовательности. Действительно, пусть нам дана
строка :math:`s`. Возьмём :math:`s_1=s`, а в качестве :math:`s_2`
возьмём перевёрнутую :math:`s`, т.е. строку :math:`s`, записанную задом
наперёд — и найдём наибольшую общую подпоследовательность для
:math:`s_1` и :math:`s_2`. Кажется, она и будет ответом на начальную
задачу, т.е. наибольшим подпалиндромом для :math:`s`\ … Но не очевидно.
Очевидно, что каждый подпалиндром будет общей подпоследовательностью, но
обратное неверно. Можно доказать, что среди наибольших общих
подпоследовательностей всегда найдется палиндром, т.е. что длина
палиндрома таким алгоритмом будет определена верно, но есть примеры,
когда есть несколько наибольших общих подпоследовательностей, и не все
из них являются палиндромами. Таким образом, есть опасность правильно
найти длину, но вывести неправильный ответ.

Поэтому сведение одной задачи к другой здесь, как мне кажется, очень
непродуктивный путь. Вам потребуется тщательно проверять его
корректность, а может даже оказаться, что задача-то и не сведётся. Более
правильно, на мой взгляд, попытаться понять, *чем* так похожи задачи, и
перенести *идеи* динамического решения второй задачи на первую. Если вы
знаете, как решать вторую задачу, то вы знаете, какие надо выбрать
подзадачи, как вывести рекуррентное соотношение… — попробуйте перенести
эти идеи по аналогии на первую задачу. *Не бойтесь* придумать
динамическое решение!

На самом деле это довольно важная идея!

Пример. Задача: найти наибольшую общую подпоследовательность *трёх*
строк. Т.е. найти наидлиннейшую строку, которую можно получить из любой
из трёх данных, вычёркивая некоторые символы. Может показаться, что эту
задачу можно свести к только что разобранной, например: найдём
наибольшую общую подпоследовательность первых двух строк, а потом найдём
наибольшую общую подпоследовательность полученной строки и третьей
строки. Или: найдём наибольшую общую подпоследовательность первой и
второй строки, потом — второй и третьей строки, а потом — двух
найденных. Но нет, так не получится.



.. task::

    Придумайте контрпримеры к двум приведённым способам решения
    этой задачи
    |
    |
    Контрпример, например, такой:
    ``s_1="abcd"``, ``s_2="adbc"`` и
    ``s_3="ad"``. НОП первых двух строк — ``abc``, и
    буква ``d`` пропала. Что дальше ни делай, но правильного ответа
    ``ad`` не получим.
    |



.. task::

    Решите задачу о наибольшей общей подпоследовательности трёх
    строк по аналогии с задачей для двух строк.
    |
    Аналогия тут полная,
    только решение будет кубическое: для каждых :math:`(i,j,k)` найдём
    наибольшую общую подпоследовательность понятно чего.
    |
    Пусть
    :math:`ans[i,j,k]` — длина наибольшей общей подпоследовательности для
    первых :math:`i` символов первой строки, первых :math:`j` второй и
    первых :math:`k` третьей. Тогда если :math:`s_1[i]=s_2[j]=s_3[k]`, то
    ответ :math:`ans[i-1,j-1,k-1]+1`, иначе нужно какую-то букву вычеркнуть.
    Окончательно
    
    .. math::
    
        ans[i,j,k]=\left\{\begin{array}{ll}
        ans[i-1,j-1,k-1]+1,\quad&\text{если }s_1[i]=s_2[j]=s_3[k],\\
        \max(ans[i-1,j,k],ans[i,j-1,k],ans[i,j,k-1]),\quad&\text{иначе.}
        \end{array}\right.
    
    
    |

Если вы решили эту задачу, то видите, что *методы* перенеслись очень
легко. Если вы знаете ДП-решение задачи, аналогичной той, что дана вам,
то не бойтесь решать данную вам *аналогично* известной вам: это,
наверное, будет несложно. А вот свести одну задачу к другой может быть
намного сложнее.

Ещё один пример на эту тему, как я уже сказал, задача про наибольший
подпалиндром. Мы её сейчас рассмотрим; я не буду специально указывать на
аналогию идей с максимальной подпоследовательностью, но при желании вы
можете её проследить.



.. _subsequence:



ДП на подотрезках
-----------------

Итак, тут мы и рассмотрим задачу о наибольшем подпалиндроме. Это (или
близкая к ней задача) — задача с межнара’2000, и это та задача, на
которой я сам понял суть ДП. Осенью 2000 года я раздобыл решение Михаила
Баутина (на самом деле его раздобыл Александр Пономаренко, и дал копию
мне). Решение набирало максбалл (конечно, максбалл — он тогда
максбалл на каждой задаче набрал), и я пытался понять, *как* эти пять
строчек могут решать эту задачу?! Но потом вдруг в какой-то момент я
понял.

Итак, как решается эта задача. Дана строка :math:`s`, надо найти её
наибольший подпалиндром. Попробую показать, как можно дойти до такого
решения (хотя как будет видно далее, окончательная идея — просто
стандартная идея ДП на подотрезках, и поэтому можно и сразу догадаться,
как решать). Давайте попробуем выбрать такие подзадачи: для каждого
:math:`i` посчитаем :math:`ans[i]` — длину наибольшего подпалиндрома
первых :math:`i` символов строки :math:`s`. На что может заканчиваться
такой палиндром? Ну, очевидно. Он либо содержит символ :math:`s[i]`,
либо нет. Если не содержит, то все просто — ответ будет равен
:math:`ans[i-1]`. А если содержит?.. Хм. Не так все просто, как могло
показаться сначала. Если содержит, то последний символ нашего палиндрома
будет :math:`s[i]`, тогда первый символ палиндрома должен с ним
совпадать. Тогда вроде надо бы найти, где *первый раз* такой символ
входит в нашу строку — пусть это позиция :math:`j`, т.е.
:math:`s[j]=s[i]`, и раньше позиции :math:`j` этот символ не встречался.
Тогда это вхождение и будет первым символом искомого палиндрома, а
оставшаяся часть безусловно будет максимальным подпалиндромом… только
для строки :math:`s[j+1\dots i-1]`, т.е. для подстроки строки
начинающейся с позиции :math:`j+1` и идущей до позиции :math:`i-1`. Но
мы для такой задачи ответа не знаем, это не есть одна из наших подзадач…

Но тогда ясно, что нужно попробовать немного по-другому. Что-то типа
рекуррентного соотношения вырисовывается, но для немного других
подзадач. Ну давайте и последуем этой идее. Нам надо знать ответ для
любой подстроки, а не только для подстрок, начинающихся с первой позиции
строки :math:`s`? Так давайте так и поступим!

Итак, новые подзадачи: для каждого :math:`l` и :math:`r` такого, что
:math:`l\leq r`, вычислим :math:`ans[l,r]` — длину наибольшего
подпалиндрома для строки :math:`s[l\dots r]`, т.е. подстроки нашей
строки, начинающейся с позиции :math:`l` и заканчивающейся позицией
:math:`r`. Ясно, что мы считаем? Если :math:`s={'\texttt{abcbdefba}'}`,
то :math:`ans[4,8]` будет хранить длину наибольшего подпалиндрома для
строки ``bdefb`` (которая равна 3, очевидно). Как вычислить
:math:`ans[l,r]`? Легко: посмотрим, *на что может заканчиваться* искомый
палиндром. Мы ведь уже имеем общее представление о том, что надо делать.
Палиндром либо содержит последний символ строки, т.е. символ
:math:`s[r]`, либо нет. Если нет, то :math:`ans[l,r]=ans[l,r-1]`. А если
содержит? Ну вроде даже понятно: надо найти, где первый раз в нашей
текущей строке :math:`s[l\dots r]` входит символ, равный :math:`s[r]` —
пусть это будет позиция :math:`j`, и тогда
:math:`ans[l,r]=ans[j+1,r-1]+2` (два, т.к. к палиндрому-ответу на задачу
:math:`(j+1,r-1)` мы дописали два одинаковых символа: :math:`s[j]` слева
и :math:`s[r]` справа). 

Казалось бы, всё, но тут ещё возникает
стандартная оптимизация, которая часто появляется и в других задачах на
ДП. А именно, зачем нам явно искать такой символ :math:`j`? Могут быть
два варианта: либо :math:`j=l`, либо :math:`j\neq l`. В последнем
случае, очевидно, это обозначает, что символ :math:`s[l]` в ответ не
входит, и ответ будет равен :math:`ans[l+1,r]` (напомню, что мы
рассматриваем пока случай, когда в ответ входит символ :math:`s[r]`), во
втором случае (:math:`j=l`) получаем, что :math:`s[l]=s[r]` и очевидно,
что ответ равен :math:`s[l+1,r-1]+2`.

Постарайтесь осознать этот переход, почему и как так получилось, что от
цикла поиска :math:`j` мы избавились. Такой переход очень часто встречается
в задачах на динамику, и надо уметь его видеть.
Дополнительное замечание, которое
может это объяснить: если :math:`j\neq l`, то при вычислении
:math:`ans[l+1,r]` мы бы нашли *то же самое* значение :math:`j`, так что
зачем его ещё раз искать — ясно, что :math:`ans[l,r]` в таком случае так
или иначе сведётся к :math:`ans[l+1,r]`.

Итак, вроде рекуррентное соотношение вырисовалось. Давайте ещё раз для
ясности:

- если :math:`s[l]=s[r]`, то :math:`ans[l,r]=2+ans[l+1,r-1]`,
- иначе есть два варианта: либо в ответ не входит символ :math:`s[r]`,
  либо он входит, но тогда не входит :math:`s[l]`. Т.е. в этом случае
  ответ есть :math:`\max(ans[l+1,r],ans[l,r+1])`.

Окончательно:

.. math::

   ans[l,r]=\left\{\begin{array}{ll}
   \max(ans[l+1,r],ans[l,r-1]),\qquad&{если\ }s[l]\neq s[r]\\
   ans[l+1,r-1]+2,\qquad&{если\ }s[l]=s[r]
   \end{array}\right.



.. task::

    На самом деле строго мы это ещё не доказали. Докажите.
    
    |
    Тут, кстати, аналогия с наибольшей общей подпоследовательностью (и
    с :ref:`соответствующей задачей <LCS:proof>`) проявляется наиболее ярко.
    |
    Рассмотрим
    случай :math:`s[l]=s[r]`. Если в оптимальном для :math:`(l,r)` решении
    мы обе эти буквы вычёркиваем, то решение не оптимальное — можно их не
    вычёркивать и получить решение на 2 символа длиннее. Значит, хотя бы
    один из этих двух символов мы сохраняем. Пусть мы сохраняем
    :math:`s[l]`, и :math:`s[r]` вычёркиваем — тогда пусть последний
    невычеркнутый справа символ :math:`s[r']`. Тогда :math:`s[r']=s[l]=s[r]`
    и мы можем вычеркнуть :math:`s[r']`, но оставить :math:`s[r]` — решение
    останется решением и останется оптимальным. Значит, есть оптимальное
    решение, где мы не вычёркиваем ни :math:`s[l]`, ни :math:`s[r]`. Но
    тогда несложно показать, что :math:`ans[l,r]=ans[l-1,r+1]+2`.
    
    Если же :math:`s[l]\neq s[r]`, то надо как минимум одну вычеркнуть. Если
    вычёркиваем :math:`s[l]`, то ответ равен :math:`ans[l+1,r]`, независимо
    от того, вычёркиваем ли мы :math:`s[r]`. Аналогично с :math:`s[r]`.
    Общий итог — :math:`ans[l,r]=\max(ans[l+1,r],ans[l,r-1])`.
    |

Обратите внимание на «базу» динамики. Я бы рассмотрел с качестве базы
:math:`ans[l,l]=1` и :math:`ans[l+1,l]=0` (второе соотношение —
некоторый аналог «нулевой строки»; на него будут ссылаться значения
:math:`ans[l,l+1]`, если :math:`s[l]=s[l+1]`).

(Теперь, если вдуматься, то становится видна аналогия с предыдущим
пунктом, с задачей о наибольшей общей подпоследовательности двух
последовательностей. Она, конечно, не очевидна, но, по-моему, она
все-таки есть.)

Итак, общая концепция динамики на подотрезках. Есть некоторая
последовательность, строка и т.п. Параметрами динамики будут являться
:math:`l` и :math:`r` — левая и правая граница некоторого куска этой
строки / последовательности / …; соответственно, эту подзадачу сводим к
более мелким. Инициализация обычно происходит для случаев :math:`l=r`
или :math:`l=r-1`. Обращу внимание на то, в каком порядке надо вычислять
элементы (конечно, это относится к случаю, когда вы пишете динамику
просмотром вперёд или назад, а не рекурсией с запоминанием результата).
Иногда бывает так, что для вычисления можно просто организовать пару
вложенных циклов по :math:`l` и :math:`r` типа

::

    for l:=1 to n do
        for r:=l+1 to n do {обратите внимание, что здесь r>l всегда}
            вычислить элемент ans[l,r]

Но в большинстве случаев так не получается, в том числе так не получится
в нашей задаче про подпалиндром. Действительно, у нас подзадача
:math:`(l,r)` зависит от :math:`(l,r-1)`, :math:`(l+1,r)` и
:math:`(l+1,r-1)`, т.е. ответы на эти три подзадачи должны быть
вычислены до вычисления :math:`(l,r)`. В приведённом же выше коде
подзадачи :math:`(l+1,r)` и :math:`(l+1,r-1)` вычисляются позже
:math:`(l,r)`.

Но очевидно, как эту проблему обойти. Действительно, каждая задача у нас
зависит только от задач с более коротким куском (задача :math:`(l,r)`
зависит от задач :math:`(l',r')` таких, что :math:`r'-l'<r-l`), и это
почти всегда так в динамике на подотрезках. Поэтому организуем
вычисления в порядке увеличения длины куска. У нас будут два вложенных
цикла: внешний по длине куска :math:`len`, внутренний — например, по
позиции начала куска :math:`l`. Соответствующее :math:`r` будет равно
:math:`l+len-1`, т.е. получаем такой код:

::

    for len:=1 to n do
        for l:=1 to n-len+1 do begin {обратите внимание на аккуратное значение верхнего предела}
          r:=l+len-1;
          вычислить элемент ans[l,r]
        end;

Таким образом, всегда, когда мы доберёмся до задачи :math:`(l,r)`, все
задачи, от которых она зависит, уже будут решены.



.. task::

    Напишите решение задачи про максимальный подпалиндром.
    
    |
    |
    
    
    ::
    
        fillchar(ams,sizeof(ans),0);
        for i:=1 to n-1 do
            ans[i+1,i]:=0;
        for len:=2 to n do
            for l:=1 to n-len+1 do begin {обратите внимание на аккуратное значение верхнего предела}
              r:=l+len-1;
              if s[l]=s[r] then
                 ans[l,r]:=ans[l+1,r-1] + 2
              else ans[l,r]:=max(ans[l+1,r],ans[l,r-1]);
            end;
    
    
    |



.. task::

    Важное задание! Напишите процедуру :math:`out` вывода решения в этой
    задаче.
    |
    Это — как раз пример на не совсем обычную процедуру
    :math:`out`.
    |
    
    
    ::
    
        procedure out(l,r)
        begin
        if l>r then
           exit;
        if l=r then begin
           write(s[l]);
           exit;
        end;
        if s[l]=s[r] then begin
           write(s[l]);
           out(l+1,r-1);
           write(s[r]);
        end else begin
            if ans[l+1,r]>ans[l,r-1] then
               out(l+1,r)
            else out(l,r-1);
        end;
        end;
    
    Здесь сначала два if’а, соответствующие «базе» динамики, а потом
    основной код. С вариантом, когда :math:`s[l]\neq s[r]`, все понятно, а
    вот если :math:`s[l]=s[r]`, то тут небольшая необычность. Мы делаем
    write, потом out, потом ещё раз write, в отличие от обычных процедур
    out, где мы делаем out и только потом write.
    |



.. task::

    Научитесь выводить первое в лексикографическом порядке решение
    здесь.
    |
    Тут все аналогично :ref:`задаче про первую в лексикографическим порядке общую подпоследовательность <LCS:FirstLex>`. Правда,
    тут скорее дело даже не в аналогии между задачами, а вообще в общности
    методов «тяжёлой артиллерии» для учёта таких требований.
    |
    Ну, как и в
    :ref:`задаче про первую в лексикографическим порядке общую подпоследовательность <LCS:FirstLex>`, будем вместо длины максимального
    подпалиндрома хранить сам подпалиндром. Далее, я думаю, очевидно, я даже
    не буду ни рекуррентного соотношения, ни кода приводить.
    |

Итак, я думаю, понятно, что такое динамика на подотрезках. Это —
довольно стандартная и часто встречающаяся идея, и поэтому, имея
определённый опыт, мы могли бы сразу при решении задачи о максимальном
подпалиндроме догадаться использовать её и не мучиться так, как нам
пришлось. Ничего, в будущем догадаемся.

Ещё раз отмечу, что, помимо собственно идеи о динамике на подотрезках,
мы ещё тут узнали две полезные идеи. Первая — это то, что иногда бывает
нужно расширить список рассматриваемых подзадач, чтобы суметь построить
рекуррентное соотношение, и в частности (я надеюсь), поняли, что нет
нужды заранее непонятно откуда угадывать набор подзадач, которые надо
рассматривать: если мы ошиблись с выбором подзадач, нередко мы увидим
свою ошибку и сумеем расширить рассматриваемый набор подзадач, поняв,
что именно нам надо.

Вторая идея — это то, что иногда циклы при вычислении ответа на
очередную подзадачу можно заменить просто ссылкой на предыдущую
подзадачу. Если у вас получается цикл в рекуррентном соотношении,
полезно подумать, а нельзя ли от него избавиться. Например, может быть,
если выкинуть одну итерацию цикла, то получится в точности цикл, нужный
для другой подзадачи? А тогда весь остаток цикла можно убрать, и просто
воспользоваться значением для этой подзадачи. Ещё пример на эту идею —
:ref:`задание про монеты, где каждую монету можно использовать сколько угодно раз <multi\_coins>`.

ДП по полной сумме
------------------

Это — скорее отдельное замечание, чем отдельный важный тип, но тем не
менее заметьте, что иногда бывает так, что одним из параметров динамики
мы назначаем некоторую «полную сумму». Например, в задаче про монеты
одним из параметров динамики была сумма, которую мы пытаемся набрать.

Ещё пример — дано :math:`N` отрезков, требуется сгруппировать их в две
группы так, чтобы суммарная длина в первой группе равнялась суммарной
длине во второй группе. На самом деле это в точности задача про монеты,
надо только определить, можно ли набрать сумму, равную половине общей
суммы всех отрезков. Но обратите внимание, что аналогично (при
соответствующих ограничениях, конечно) решается и задача о группировке в
три группы с равной суммарной длиной, и на четыре и т.д. Например, чтобы
разбить на пять групп, можно придумать динамику за :math:`O(NL^4)`: для
каждых :math:`l_1`, :math:`l_2`, :math:`l_3`, :math:`l_4` и :math:`i`
определим, можно ли сгруппировать первые :math:`i` отрезков в 5 групп
так, чтобы суммарная длина первой равнялась :math:`l_1`, …, четвёртой —
:math:`l_4` (а пятой — сколько останется). Переход очевиден: чтобы
определить, можно ли так сделать, переберём, в какую группу встаёт
:math:`i`-ый отрезок и посмотрим на соответствующий ответ для
:math:`i-1`. (Может быть, эту задачу можно и проще решать, но я с ходу
такого решения не знаю.)

В общем-то просто, только, может быть, не с ходу может в голову придти,
обычно все-таки у нас уже есть некоторый линейный объект, по которому мы
и строим динамику (строка, или поле, по которому ползает черепашка, или
т.п.). Обратите ещё внимание на то, что придётся считать *для каждого*
:math:`l_1`, …, :math:`l_k`, и потому в сложность входит ограничение на
суммарную длину отрезков, на которое в других условиях мы могли и не
обратить внимание.

Такого рода задачи также называются задачами о рюкзаке,
или об упаковке рюкзака, потому что в общепринятой легенде задачи упоминается рюкзак.



.. task::

    Есть :math:`N` вещей, у каждой из которых известен вес и
    стоимость. У нас есть рюкзак грузоподъемности :math:`W`, т.е. мы можем унести 
    произвольный набор вещей при условии, что их
    суммарный вес не превосходит некоторого числа :math:`W`. Требуется среди
    всех таких наборов выбрать набор с максимальной суммарной стоимостью.
    Решите эту задачу за :math:`O(NW)`: найдите ответ и выведите само
    решение.
    |
    Эта задача вам ничего из того, что мы тут разбирали, не
    напоминает? Да и не забудьте тему раздела — динамика по полной сумме.
    Правда, тут «полных сумм» две — вес и стоимость, но, я думаю, несложно
    догадаться, по какой из них надо динамику.
    |
    По-моему, эта задача
    очень напоминает задачу про монеты (а ещё больше — задачу
    :ref:`про минимальное число монет <min\_coins>`), только то, что было
    раньше достоинством монеты, теперь — вес вещи, а стоимость вещи — новый
    параметр. Поэтому решается совсем аналогично. Соответственно,
    :math:`ans[i,j]` будет обозначать, какую максимальную стоимость можно
    набрать из первых :math:`i` вещей при условии, что суммарный вес
    набранного будет ровно :math:`j` (если суммарный вес :math:`j`
    невозможно набрать из первых :math:`i` вещей, то будем тут хранить
    :math:`-\infty`). Рекуррентное соотношение пишется легко, полностью
    аналогично задаче про монеты: либо мы берём :math:`i`-ую вещь (если
    :math:`j\geq w_i`, где :math:`w_i` — вес :math:`i`-ой вещи), или нет.
    
    .. math::
    
        ans[i,j]=\left\{
        \begin{array}{ll}
        max(ans[i-1,j],ans[i-1,j-w_i]+c_i),&\quad j\geq a_i,\\
        ans[i-1,j],&\quad j<a_i,
        \end{array}\right.
    
    здесь :math:`c_i` — стоимость :math:`i`-ой вещи.
    
    «База» динамики аналогична задаче про монеты, индекс :math:`j`, конечно,
    идёт до :math:`w`, независимо от весов вещей. Вроде я нигде не наглючил.
    
    Кстати, если хотите, то это ещё один пример на «тяжёлую артиллерию» для
    вывода требуемого решения. Переформулирую задачу так: «Можно ли унести
    вещей общим весом не более :math:`W`? Если решений несколько, то
    выведите то, у которого суммарная стоимость вещей максимальна.» Теперь,
    я думаю, совершенно очевидно, что эта задача — иллюстрация к замечаниям
    в конце решения :ref:`про первую наибольшую общую подпоследовательность <LCS:FirstLex>`.
    
    Вывод решения даже писать не буду, все совершенно аналогично всему, что
    обсуждалось выше, тем более, что я приводил в основном тексте вывод
    решения для задачи про монеты.
    |

ДП на ациклических графах
-------------------------

Вам дан ациклический граф и надо в каждой вершине посчитать некоторую
величину, причём её значение для конкретной вершины легко выражается
через значения для вершин, из которых в эту идут ребра. Тогда ясно, что
можно элементарно применить ДП, единственная проблема — решать подзадачи
явно надо в оттопсорченном порядке, и потому совершенно естественно
применить тут рекурсию с запоминанием результата.

Пример: найти в ациклическом графе самый длинный путь. Будем решать
следующие подзадачи: для каждой вершины определим длину самого длинного
пути, заканчивающегося в этой вершине. Подзадача элементарно сводится к
более мелким: ответ для данной вершины есть максимум из ответов для всех
вершин, из которых в нашу идут ребра, плюс один. Особый случай — если в
нашу вершину ни одного ребра не входит, то ответ ноль.

Рекурсия с запоминанием результата пишется легко, прямо по шаблону
поиска в глубину; для пометки, в каких вершинах были, не заводим
отдельный массив, а используем массив :math:`ans` (обратите внимание,
что наш граф тут отличается от графа подзадач: в соответствии с тем, как
я выше определил граф подзадач, в нем ребра идут в другую сторону):

::

    function find(u):integer;
    var max,t,v...
    begin
    if ans[u]<>-1 then begin
       find:=ans[u];
       exit;
    end;
    max:=-1;
    for v:=1 to n do
        if gr[v,u]<>0 then begin{если из v в u идет ребро}
           t:=find(v);
           if t>max then
              max:=t;
        end;
    ans[u]:=max+1;
    find:=ans[u];
    end;

Вот и все, задача решена. Обратите внимание, что, если бы мы и захотели
бы писать ДП с просмотром вперёд/назад, то все равно сначала пришлось бы
оттопсортить, т.е. все равно написать поиск в глубину, поэтому рекурсия
с запоминанием результата — самое простое и естественное, что тут можно
сделать.

Ещё обратите внимание, что тут в коде нет уже привычных нам особых
случаев — «базы» динамики (по аналогии с базой индукции). У нас всегда
были совсем простые задачи, для которых мы ответ считали отдельно
вручную и появлялись if’ы, а тут все получилось автоматически, т.к.
«база» ДП — это те вершины, в которые не входят ребра, и все просто.
Именно для этого случая :math:`max` проинициализирована значением
:math:`-1`.



.. task::

    Напишите процедуру out вывода решения в этой задаче.
    |
    Вам
    может оказаться полезным использовать массив :math:`from`.
    |
    Итак, тут
    все не совсем уж прямолинейно по предыдущим примерам, зато это пример на
    использование массива :math:`from`. Итак, заведём массив :math:`from`, и
    в :math:`from[u]` будем хранить, на какой именно вершине нашёлся
    максимум при обработке вершины :math:`u`. Тогда основной код динамики
    немного изменится, а процедура :math:`out` будет писаться элементарно:
    
    ::
    
        function find(u):integer;
        var max,t,v...
        begin
        if ans[u]<>-1 then begin
           find:=ans[u];
           exit;
        end;
        max:=-1;
        from[u]:=0;
        for v:=1 to n do
            if gr[v,u]<>0 then begin{если из v в u идет ребро}
               t:=find(v);
               if t>max then begin
                  max:=t;
                  from[u]:=v;
               end;
            end;
        ans[u]:=max+1;
        find:=ans[u];
        end;
        procedure out(u)
        begin
        if u=0 then
           exit;
        out(from[u]);
        write(u,' ');
        end;
    
    Если в вершину :math:`u` не входит ни одного ребра, то :math:`ans[u]=1`,
    и в вышеприведённом коде :math:`from[u]=0`, потому и процедура
    :math:`out` так обрабатывает случай :math:`u=0` (допонимайте!).
    
    В общем, вот оно, использование массива :math:`from`. В принципе, и
    раньше его можно было использовать, например, в черепашке в
    :math:`from[i,j]` хранить 0 или 1 в зависимости от направления хода и
    т.п. — тогда не надо будет ещё раз в процедуре :math:`out` реализовывать
    рекуррентное соотношение. В принципе, так, наверное, даже проще.
    |

ДП на деревьях
--------------

Ещё один нередко встречающийся вариант ДП — ДП на деревьях. Пусть вам
дано подвешенное дерево (т.е. дерево, в котором выделен корень), и в
каждой его вершине надо посчитать некую величину, которая рекуррентно
выражается через ответы для сыновей этой вершины. С одной стороны, это,
безусловно, частный случай предыдущего пункта, т.к. ребра дерева можно
ориентировать по направлению от корня — и получится ациклический граф.
Если вам дерево задано в общем виде, то ничего лучше вы, наверное, не
придумаете. 

(Но все равно случай дерева встречается часто,
поэтому имеет смысл динамику на дереве считать отдельным вариантом,
а не частным случаем динамики на ациклических графах. 
В каком-то смысле типичный пример такой динамики — это алгоритм
поиска мостов и точек сочленения, где мы вычисляем
сложноописываемую величину «минимальная глубина, куда идут
ребра из поддерева текущей вершины».)

Кроме обычного варианта, когда вы перебираете детей каждой вершины,
есть один способ задания дерева, который нередко встречается прямо во
входном файле (или в другом источнике, откуда вы берете входные данные).
Вершины нумеруются так, что номер родителя всегда меньше номера любого
сына, в частности, номер корня равен 1. Далее, во входном файле просто
задано :math:`N-1` число — номера родителей для всех вершин от второй до
последней (:math:`N`-ой). Ясно, что это однозначно задаёт дерево, но это
также позволяет иногда намного проще писать ДП. В частности, в этом
случае все вершины уже оттопсорчены; ещё отмечу, что здесь легко ложится
динамика с просмотром вперёд, т.к. идти от вершины к корню легко, а
назад — сложно.

Пример. Можно тут, конечно, дать нетривиальный пример — я его дам ниже в
задании — а пока рассмотрим простую задачу. Дано дерево, найти в нем
наидлиннейший путь от корня до какого-нибудь листа.

Рекуррентное соотношение очевидно: оно то же, что и в прошлом пункте:
ответ для данной вершины есть единица плюс максимум из ответов для
сыновей; если сыновей нет, то ответ ноль.

Если дерево задано как-нибудь неудобно, то ничего лучше, чем в прошлом
разделе, вы, наверное, не придумаете (ну и не страшно! решение,
написанное как в прошлом разделе, будет работать столь же хорошо). Но
пусть дерево задано так, как я только что описал. Тогда тут легко
пишется динамика с просмотром вперёд:

::

    fillchar(ans,sizeof(ans),0);
    for i:=n downto 2 do
        if ans[i]+1>ans[p[i]] then
          ans[p[i]]:=ans[i]+1;

здесь :math:`p[i]` — родитель вершины :math:`i`.

Видите, как элегантно? Осознайте, почему это ещё и правильно и как тут
существенно используется то, что дерево задано именно в нужном виде.

Кстати, это доказательство того, что ДП с просмотром вперёд не всегда
заменяется «обращением» динамики, как в :ref:`задаче про Буратино <buratino>`.



.. task::

    Дано дерево. Найдите в нем наибольшее паросочетание, т.е.
    набор рёбер такой, что 1) никакие два ребра не имеют общего конца, 2)
    число рёбер максимально возможно. Напишите как само ДП, так и процедуру
    :math:`out` вывода решения.
    |
    Будем считать, что дерево задано
    «хорошо», т.е. массивом :math:`p`. Для каждого поддерева найдём размер
    максимального паросочетания в нем… Правда, если подумать, то это
    оказывается не очень тривиально; во всяком случае, я с ходу не вижу, как
    это просто решить. Но подумайте. Полезно будет решать две задачи:
    максимальное паросочетание в поддереве с корнем в :math:`u` при условии,
    что сама вершина :math:`u` входит в паросочетание, и при условии, что не
    входит. Написать рекуррентное соотношение несложно, но реализовать ДП с
    просмотром вперёд сложнее.
    |
    Итак, для каждого поддерева решаем две
    указанные в подсказке задачи. Пусть ответ на первую — :math:`a[u]`, на
    вторую — :math:`b[u]`. Очевидна формула для :math:`b[u]`:
    
    .. math:: b[u]=\sum_v c[v],
    
    сумма берётся по всем детям вершины :math:`u`, здесь
    :math:`c[v]=max\big(a[v],b[v]\big)` — максимальное паросочетание в
    поддереве :math:`v` без всяких ограничений.
    
    Как найти :math:`a[u]`? Ну легко: если :math:`u` входит в паросочетание,
    то :math:`u` связана с неким своим сыном :math:`v`. Тогда размер
    паросочетания равен :math:`1+b[v]` плюс максимальное вообще
    паросочетание в поддеревьях остальных детей. По :math:`v`, конечно, надо
    взять максимум:
    
    .. math:: a[u]=\max_v \bigg(1+b[v]+\sum_{v'\neq v} c[v']\bigg),
    
    максимум берётся по всем детям вершины :math:`u`, сумма — по всем
    детям, кроме :math:`v`, Соответственно, внутренняя сумма — это
    максимальное паросочетание во всех дочерних поддеревьях, кроме поддерева
    :math:`v`.
    
    Но считать сумму для каждых :math:`u` и :math:`v` не хочется. Поэтому
    идёт стандартный трюк — добавим и вычтем слагаемое :math:`c[v]`, тем
    самым превратив сумму в сумму по всем детям вообще, т.е. в :math:`b[u]`,
    и вынесем её из-под максимума, чтобы максимум легко находился с помощью
    просмотра вперёд:
    
    .. math:: a[u]=\max_v \Big(b[v]-c[v]\Big)+b[u]+1.
    
    (Соотношение, по-моему, неочевидно и с ходу не ясно, почему оно верно.
    Но оно верно, т.к. мы его только что вывели.)
    
    Теперь пишем ДП с просмотром вперёд, вычисляя величину :math:`b`
    элементарно, для величины :math:`a` динамикой вычисляем максимум, а
    второе слагаемое к нему прибавляем уже при обработке соответствующей
    вершины, там же вычисляем и :math:`c`:
    
    ::
    
        fillchar(a,sizeof(a),255); 
        fillchar(b,sizeof(b),0);
        fillchar(c,sizeof(c),0);
        for i:=n downto 2 do begin
            {заканчиваем обработку вершины i}
            a[i]:=a[i]+b[i]+1;
            c[i]:=max(a[i],b[i]);
            {смотрим на задачи, которые зависят от i}
            b[p[i]]:=b[p[i]]+c[i];
            a[p[i]]:=max(a[p[i]], b[i]-c[i]);
        end;
    
    Обратите внимание, что массив :math:`a` изначально заполняю минус
    единицами (ясно, почему? И какого типа должно быть :math:`a`, чтобы это
    работало?), чтобы для листьев правильно в основном цикле
    вычислялся \ :math:`a[i]`.
    
    Постарайтесь это дело понять. Тут, имхо, весьма нетривиально получилось
    (надеюсь, я тут нигде не наглючил), но это неплохой пример на ДП с
    просмотром вперёд. Помоделируйте, что здесь происходит.
    
    Кстати, может быть, тут можно додуматься до каких-нибудь дополнительных
    соображений, которые это все упростят. Например, мне кажется, что *не*
    включать корень поддерева в паросочетание всегда бессмысленно, и потому,
    может быть, всегда :math:`c[i]=a[i]`. Не знаю, поможет ли это.
    |

Игры
----

В отличие от остальных подпунктов в этом разделе это, конечно, не совсем
особый вид задач на ДП, и не особый приём реализации ДП. Это, скорее,
класс задач, которые стандартным образом сводятся к ДП, но я его решил
рассказать здесь, т.к. довольно логично его рассказывать после динамики
на ациклических графах.

Задачи на игры обычно состоят в следующем. Рассматривается некоторая
игра, которую обычно можно представить в виде графа, вершины которого
являются позициями, которые могут возникнуть в игре, а ребра — возможные
в игре ходы. В условии задаются правила, по которым определяется
победитель, начальная позиция в игре, и т.д. Требуется определить, кто
выиграет «при правильной игре», т.е. при условии, что игроки не будут
ошибаться.

Если граф позиций содержит циклы, то это позволяет игре, вообще говоря,
продолжаться до бесконечности, что сильно осложняет задачу — такие задачи
тоже можно решать, но более сложным методом, не имеющим прямого отношения к динамике. 
Но часто встречаются игры, в которых
граф позиций ациклический. (Могут быть задачи, где на первый
взгляд граф содержит циклы, но игра не может продолжаться до
бесконечности. Тогда, скорее всего, можно так переопределить позицию,
что граф будет все-таки ациклическим; см. пример в задании ниже.)

Если граф ациклический, то задача обычно решается динамикой по
позициям. В общем случае конкретные вычисляемые значения могут быть
разными, я приведу два примера.

Первый пример. Пусть игроки ходят по очереди и пусть для каждой позиции,
из которой нет ходов, определено, кто в ней выиграл — тот, кто в неё
пришёл, или наоборот. (Обычно бывает сказано типа «Проигрывает тот, кто
не может сделать ход».) Тогда для всех позиции в игре можно определить,
кто в ней выигрывает — тот, кто из неё ходит, или его противник. Этот
метод часто обсуждается на математических кружках как «метод выигрышных
и проигрышных позиций», но по сути это именно алгоритм, причём
являющийся частным случаем ДП.

Итак, позицию назовём выигрышной, если тот, кто из неё ходит, выигрывает
при правильной игре, иначе проигрышной. Тип каждой позиции однозначно и
достаточно легко зависит от типов тех позиций, в которые из неё можно
пойти. Действительно, если из позиции :math:`u` есть ход в какую-нибудь
проигрышную позицию :math:`v`, то, очевидно, :math:`u` — выигрышная
позиция, и для победы при нашем ходе из позиции :math:`u` нам надо
просто сходит в позицию :math:`v`. Оттуда будет ходить наш противник, и
он проиграет, т.к. :math:`v` проигрышная — значит, мы выиграем. А вот
если из позиции :math:`u` нет ходов в проигрышные позиции, т.е. *все*
ходы из неё — в выигрышные, то нам деваться некуда: куда мы не пойдём,
противник выиграет. Значит, :math:`u` — проигрышная позиция.

Итак, мы получили, фактически, рекуррентное соотношение: как определить
тип позиции :math:`u`, зная типы позиций, в которые возможен ход из
:math:`u`. Тип позиций, из которых нет ходов, мы знаем по условию,
поэтому можем с помощью динамики определить типы всех остальных позиций,
т.е. решить задачу.

Отмечу, что динамика тут вовсе не обязана быть динамикой на ациклических
графах, это может быть и одномерная динамика, и динамика на подотрезках,
и динамика по подмножествам (см. ниже) и любая другая, все зависит игры.

Пример. В куче лежит :math:`N` камней. За один ход каждый игрок может
взять от 1 до :math:`M` камней. Проигрывает тот, кто не может сделать
ход. Дано :math:`N` и :math:`M`, определите, кто выигрывает при
правильной игре.

В этой задаче есть элементарная закономерность и, может быть, вы даже её
знаете. Но мы не будем её искать, а будет писать динамическое решение. В
массиве :math:`ans` храним тип позиции: :math:`ans[i]=1`, если позиция
:math:`i` (т.е. куча с :math:`i` камнями) выигрышна, и :math:`ans[i]=2`,
если проигрышна. :math:`ans[0]=2` по условию (осознайте это!). Динамика
пишется легко:

::

    ans[0]:=2;
    for i:=1 to n do begin
        ans[i]:=2;
        for j:=1 to m do
            if (j<=i)and(ans[i-j]=2) then
               ans[i]:=1;
    end;

Разберитесь, почему это верно. Обратите внимание, что это не динамика по
графу, а обычная линейная динамика.

Ещё пример. То же самое, но каждым ходом можно брать не больше, чем
предыдущим ходом взял противник. Здесь позиция уже однозначно не
определяется количеством камней в куче, надо ещё и хранить, сколько
предыдущим ходом взял противник. Т.е. позиция будет :math:`(i,j)`:
:math:`i` камней в куче и первым ходом можно взять не более :math:`j`
камней. Додумайте.



.. task::

    Додумайте эту задачу.
    |
    |
    Позицией здесь в игре будет пара
    чисел :math:`(i,j)`, указывающих, что в куче осталось :math:`i` камней,
    а первым ходом можно взять не более :math:`j` камней. Тогда возможные
    ходы — взять от 1 до :math:`j` камней, и ясно, в какие позиции они
    ведут. Получаем код:
    
    ::
    
        fillchar(ans,sizeof(ans),2); {осторожно тут с типом ans}
        for i:=1 to n do 
            for j:=1 to m do begin
                {ans[i,j] уже равно 2}
                for k:=1 to j do
                    if (k<=i)and(ans[i-k,k]=2) then
                      ans[i,j]:=1;
            end;
        end;
    
    Вот и все решение, мне кажется, достаточно просто. На самом деле в этой
    задаче есть хитрая закономерность, можете её поискать (совет: напишите
    программу и выведите в выходной файл ответы для каждого :math:`i` и
    :math:`j`) и доказать, но обратите внимание, что наше решение ни на
    какую закономерность не опирается.
    |

Надеюсь, что метод выигрышных и проигрышных позиций понятен и ясно, как
его применять даже для произвольных игр такого рода. Второй часто
распространённый вариант состоит в следующем. За каждый ход один игрок
платит другому некоторую сумму денег, в конечных позициях также
определено, сколько игроки должны друг другу заплатить. Требуется
определить, какую максимальную сумму денег может получить первый игрок
(и, соответственно, потерять второй) при правильной игре.

Такой вид задач также решается динамикой, только теперь для каждой
позиции считаем, сколько максимум выигрывает игрок, ходящий из этой
позиции. Определяем это легко: перебираем все возможные ход. Пусть за
некоторый ход мы должны заплатить противнику сумму :math:`a`, и при этом
мы уже знаем, что ответ для той позиции, куда ведёт этот ход, равен
:math:`b` (как :math:`a`, так и :math:`b` может быть и положительным, и
отрицательным, конечно). Тогда если мы изберём этот ход, то противник
сразу получит сумму :math:`a`, а потом, играя из той позиции, куда мы
попали, он получит ещё :math:`b`, т.е. общий доход противника будет
:math:`a+b`, значит, наш доход будет :math:`(-a-b)`. Выбрав максимум по
всем ходам, мы найдём ответ для текущей позиции. Я не буду приводить
примера задачи, но подумайте и попробуйте придумать пример сами :)

Аналогично решаются и другие задачи на игры. Т.е. вы всегда вычисляете
что-то для каждой позиции, а что именно — зависит от игры. Вычисляете
это, перебирая все возможные ходы и используя ответы для тех позиций,
куда это ходы ведут.

.. note::
    Кстати, можете обратить внимание, что на самом деле только
    алгоритм такого рода доказывает корректность введения термина «при
    правильной игре». Откуда мы знаем, что из каждой позиции есть
    «правильная игра» и откуда мы знаем, что результат определён? А именно
    по индукции, идя от конечных позиций и используя соображения,
    аналогичные вышеописанным, мы докажем, что действительно определён.

Иногда бывает так, что игроки в каком-то смысле несимметричны. Например,
игроки ходят не по очереди, а для каждой позиции задано, кто из неё
ходит: из некоторых позиций ходит всегда Вова, из некоторых — Юра. Тогда
все аналогично, только удобнее ответ определять не для «текущего»
игрока, а, например, для Вовы (т.е.: если начать играть из этой позиции,
то выиграет ли Вова? или: если начать из этой позиции, то какую
максимальную сумму заработает Вова?)

Аналогичная идея — в следующей задаче.



.. task::

    В кучке лежат :math:`N` камешков. Двое игроков ходят по
    очереди. Первый своим ходом может взять из кучи от 3 до 5 камешков,
    второй — добавить в кучу 1 или 2 камешка. Выигрывает тот, после чьего
    хода камешков в куче не останется или количество камешков в куче будет
    делиться на 30, либо после чьего хода противник не сможет сходить. Кто
    выигрывает при правильной игре? (Эту задачу я только что придумал. Может
    так оказаться, что тут есть простая закономерность, например, всегда
    выигрывает второй, я не знаю. Но в любом случае придумайте динамическое
    решение за :math:`O(N)`.)
    |
    На первый взгляд может показаться, что
    здесь граф неациклический: ведь второй игрок может увеличивать
    количество камешков в куче. Но на самом деле, т.к. игроки ходят по
    очереди, и первый всегда берет больше, чем второй кладёт, то ясно, что
    на самом деле граф ациклический, только под позицией надо понимать пару
    :math:`(i,j)`, где :math:`i` — количество камешков в группе, а :math:`j`
    — тот, кто сейчас ходит (т.е. :math:`j` равно 1 или 2).
    |
    Итак, для
    каждого :math:`i` и :math:`j` определим, является ли позиция с :math:`i`
    камешками выигрышной для игрока :math:`j`. Ясно, какие ходы отсюда
    возможны, и ясно, в какие позиции они ведут. Только, чтобы не возиться с
    определением порядка, в котором надо решать подзадачи, напишем рекурсию
    с запоминанием результата. Теперь :math:`ans[i,j]=2`, если игрок
    :math:`j` проигрывает из этой позиции, и :math:`1`, если выигрывает.
    
    ::
    
        function find(i,j)
        begin
        if i<0 then begin
           find:=1;
           exit;
        end;
        if i mod 30=0 then
           find:=2;
           exit;
        end;
        if ans[i,j]=-1 then begin
           ans[i,j]:=2;
           if j=1 then begin
              if (find(i-3,2)=2) or (find(i-4,2)=2) 
                           or (find(i-5,2)=2) then
                 ans[i,j]:=1;
           end else begin {j=2}
              if (find(i+1,1)=2) or (find(i+2,1)=2)then
                 ans[i,j]:=1;
           end;
        end;
        find:=ans[i,j];
        end;
    
    Поймите, почему так обрабатывается случаи :math:`i<0` и
    :math:`i\bmod 30=0`.
    |

ДП на подмножествах
-------------------

Ещё одна полезная идея ДП бывает следующая. Пусть нам дано некоторое
множество объектов. Давайте одним из параметров динамики будет
*подмножество* этого множества, т.е. в простейшем варианте просто
посчитаем то, что нам надо, для каждого подмножества этого множества (в
более сложном варианте, конечно, могут быть дополнительные параметры у
динамики). Конечно, таких подмножеств будет :math:`2^n`, где :math:`n` —
количество таких объектов, и потому при больших :math:`n` ничего не
получится, но при :math:`n` до :math:`20` и даже немного больше вполне
сойдёт. (Кстати, если у вас в задаче есть ограничение типа
:math:`n\leq 18`, то тут можно сразу заподозрить алгоритмы с
асимптотикой типа :math:`2^n`, в том числе, и динамику по подмножествам)

Пример. Паросочетание в произвольном (неориентированном) графе. Дан
граф, требуется найти в нем максимальное паросочетание, т.е. набор рёбер
такой, что 1) никакие два ребра не имеют общего конца, 2) число рёбер
максимально возможно.

Для деревьев эта задача решается легко, см. выше. Для двудольных графов
есть алгоритм решения за :math:`O(N^3)`, а мы попробуем решить эту
задачу для произвольных графов.

В принципе, вроде существует полиномиальный алгоритм решения этой задачи
для произвольных графов, но я его не знаю и мы его обсуждать не будем.
Попробуем научиться решать эту задачу для не очень больших :math:`n`.

Идея такая: для каждого подмножества множества вершин найдём наибольшее
паросочетание (точнее, конечно, его размер) на этом наборе вершин (т.е.
размер самого большого паросочетания из всех, у которых все концы всех
рёбер лежат в нашем подмножестве вершин). Как это сделать? Ну если это
подмножество пустое, то ответ, очевидно, ноль. Иначе возьмём первую
вершину. Она либо входит в искомое паросочетание (т.е. является концом
одного из рёбер), либо нет. В последнем случае, очевидно, размер
паросочетания будет равен ответу для подмножества, не содержащего эту
вершину, а в первом случае можно перебрать, какая вершина будет вторым
концом соответствующего ребра; для каждого варианта ответ очевиден —
единица плюс ответ для подмножества, не содержащего эти две вершины (я
тут довольно мутно пишу, но это потому, что объяснить словами это,
видимо, непросто, формулы писать я не хочу, т.к. тут все очевидно, и
думаю, что вы и так все поняли или даже сами догадались).

Как это писать? Подмножество будем кодировать двоичных числом, в котором
:math:`i`-ый бит равен единице, если :math:`i`-ая вершина входит в
подмножество, и нулю, если нет. При этом вершины приходится нумеровать с
нуля, а подмножества будут кодироваться числами от 0 до :math:`2^N-1`.
Обратите внимание, что если множество :math:`A` является подмножеством
:math:`B`, то номер :math:`A` строго меньше, чем номер :math:`B`. Вполне
естественно, что во всех задачах на динамику по подмножествам ответ на
данное множество зависит только от ответов на *его* подмножества,
поэтому цикл

::

    for i:=0 to (1 shl N) -1

для любой (ну ладно, для любой нормальной) ДП по подмножествам
перебирает подмножества уже в оттопсорченном порядке.

(Т.е. что я тут хочу сказать. Нам надо обработать множества (вершин или
чего ещё) в правильном порядке. Обычно ответ на любое множество
:math:`A` зависит только от ответов на множества, получающиеся
выкидыванием из :math:`A` некоторых элементов — т.е. только от ответов
на подмножества множества :math:`A`. Может показаться, что перебрать
подмножества в подходящем порядке нетривиально, например, может
захотеться сначала решить задачи для множеств из одного элемента, потом
из двух и т.д. — но так мучиться обычно вовсе не надо: цикл, приведённый
выше, тоже перебирает множества в подходящем порядке.)

Раз уж мы так храним множества, то ясно, что без битовой арифметики тут
не обойтись. Я не буду особенно комментировать все битовые операции,
надеюсь, что вы подумаете и все поймёте. Все на самом деле просто.
Смотрите код и разбирайтесь, что тут что делает. Код выглядит страшно,
может, можно и проще написать, но на самом деле и это не сложно. Мне,
конечно, не нравится break в конце цикла, но ничего проще я не придумал.

::

    for i:=0 to (1 shl N)-1 do begin
        ans[i]:=0;
        for j:=0 to N-1 do {перебираем вершины: они занумерованы от 0 до N-1}
            if (i and (1 shl j)<>0) then begin {если вершина j лежит в нашем множестве}
               t:=ans[i and (not (1 shl j))];   {попробуем ее выкинуть...}
               ans[i]:=t;      {...и посмотреть ответ для того, что получится}
               
                           {или переберем, какая вершина может быть парной к j-ой: 
                            она тоже должна лежать в нашем множестве и быть связана с j ребром}
               for k:=j+1 to N-1 do if (i and (1 shl k)<>0) and (gr[j,k]<>0) then begin 
                   t:=ans[i and (not (1 shl j)) and (not (1 shl k))];   {выкинем их обе и посмотрим ответ}
                   if t+1>ans[i] then
                      ans[i]:=t+1;
               end;
               break; {нам достаточно обработать только одну вершину из множества}
            end;
    end;

``i and (1 shl j)<>0`` проверяет, лежит ли вершина :math:`j` в множестве
:math:`i`; ``i and (not (1 shl j))`` даёт номер множества, получающегося
из множества :math:`i` выкидыванием вершины :math:`j`, и т.д.

Ещё раз про то, зачем тут break. Нам ведь надо взять какую-нибудь
вершину из нашего множества и далее работать с ней (т.е. попробовать её
выкинуть или найти ей пару), но по номеру множества найти какую-нибудь
вершину, лежащую в нем, сложно (точнее, легко, например, что-нибудь типа
``((i-1) and (not i))+1``, но я решил не грузить вас ещё битовой
арифметикой, да это ещё и для нуля работать не будет), поэтому и написан
такой цикл с break.



.. task::

    Напишите процедуру out вывода решения в этой задаче.
    
    |
    Совершенно стандартно: пишем процедуру :math:`out(i)`, которая будет
    выводить решение для множества :math:`i`. Может быть, на первый взгляд
    хочется в процедуре :math:`out` заново перебирать все варианты, как в
    основном коде динамики — но нет, этого не надо. Достаточно сделать
    массив :math:`from`, в котором хранить, где мы нашли наилучшее решение
    для данного :math:`i`.
    
    Ещё может быть полезным сделать массив :math:`first`, и в
    :math:`first[i]` хранить номер первой вершины, лежащей в множестве
    :math:`i` (т.е. то :math:`j`, которое использовалось в основном цикле
    динамики), чтобы не делать заново цикл по :math:`j`.
    |
    Итак, мы
    перепишем немного динамику, чтобы сохранять массивы :math:`from` и
    :math:`first`. Обратите внимание, что у нас есть два глобальных
    варианта: либо мы вообще выкидываем вершину :math:`j`, либо находим ей
    пару. Но не страшно, можно просто в :math:`from` особым значением
    (например, нулём) отмечать выкидывание этой вершины. Итак, получаем
    следующий текст, новые строки помечены комментариями:
    
    ::
    
        for i:=0 to (1 shl N)-1 do begin
            ans[i]:=0;
            for j:=0 to N-1 do 
                if (i and (1 shl j)<>0) then begin 
                   first[i]:=j;                            {+}
                   from[i]:=0;                             {+}
                   t:=ans[i and (not (1 shl j))];  
                   ans[i]:=t;     
    
                   for k:=j+1 to N-1 do if (i and (1 shl k)<>0) and (gr[j,k]<>0) then begin 
                       t:=ans[i and (not (1 shl j)) and (not (1 shl k))];   
                       if t+1>ans[i] then begin
                          ans[i]:=t+1;
                          from[i]:=k;                      {+}
                       end;
                   end;
                   break;
                end;
        end;
    
    И теперь процедура :math:`out` пишется в две строчки:
    
    ::
    
        procedure out(i)
        var j;
        begin
        if i=0 then exit; {i=0 --- пустое множество --- "база" динамики}
        j:=first[i];
        if from[i]=0 then 
           out(i and (not (1 shl j)));
        else begin
             writeln(j,' ',from[i]); {выведем, что это ребро входит в паросочетание}
             out(i and (not (1 shl j)) and (not (1 shl k)));
        end;
        end;
    
    Надеюсь, понятны два момента. Во-первых, то, что в общем случае можно
    использовать не только один массив :math:`from`, но и что-нибудь сложнее
    (два массива, или структуру и т.п.) для хранения всей той информации,
    которая все равно явно или неявно вычисляется в процессе основного цикла
    динамики и потом нужна в процедуре :math:`out`. Во-вторых, в массиве
    :math:`from` мы не обязаны хранить непосредственный номер подзадачи, от
    которой зависит наша задача, а можно и что-нибудь другое полезное,
    причём можно вводить особые значения для особых случаев и т.д.
    
    И ещё отмечу, что, конечно, можно было ничего этого не вводить (если,
    например, памяти не хватает), а заново проводить все циклы по :math:`j`
    и по :math:`k`, «вспоминая», какие были значения у оптимальных величин.
    
    |

В общем, я надеюсь, идея динамики по подмножествам вам понятна. Помимо
самой идеи, тут ещё важна нумерация множеств, тот факт, что цикл от
:math:`0` до :math:`2^N-1` все решает, и тот факт, что многие действия
делаются битовой арифметикой, в том числе — важное действие — проверка,
лежит ли элемент :math:`j` в множестве :math:`i`.

Ещё отмечу, что тут требуется :math:`O(2^n)` памяти. Смотрите,
как бы вам не вылезти за ограничение памяти.



.. task::

    `Задача «Перестановки» с региона-2009 <https://algoprog.ru/material/p1212>`_. 
    
    Задано множество из :math:`n` различных натуральных чисел. 
    Перестановку элементов этого множества назовем :math:`k`-перестановкой, 
    если для любых двух соседних элементов этой перестановки их наибольший общий делитель не менее :math:`k`. 
    Например, если задано множество элементов :math:`S = {6, 3, 9, 8}`, то перестановка :math:`{8, 6, 3, 9}`
    является 2-перестановкой, а перестановка :math:`{6, 8, 3, 9}` – нет.

    Перестановка :math:`{p_1, p_2, \dots, p_n}` будет лексикографически меньше перестановки 
    :math:`{q_1, q_2, \dots, q_n}`, если существует такое натуральное число :math:`i` (:math:`1 ≤ i ≤ n`), 
    для которого :math:`p_j = q_j` при :math:`j < i` и :math:`p_i < q_i`.

    В качестве примера упорядочим все :math:`k`-перестановки заданного выше множества в лексикографическом порядке. 
    Например, существует ровно четыре 2-перестановки множества :math:`S`: :math:`{3, 9, 6, 8}`, :math:`{8, 6, 3, 9}`, 
    :math:`{8, 6, 9, 3}` и :math:`{9, 3, 6, 8}`. Соответственно, первой 2-перестановкой в лексикографическом порядке
    является множество :math:`{3, 9, 6, 8}`, а четвертой – множество :math:`{9, 3, 6, 8}`.

    Требуется написать программу, позволяющую найти :math:`m`-ую :math:`k`-перестановку в этом порядке.

    (конец условия задачи)
    
    ...на самом деле это —
    отличная задача на теорию ДП. Вам потребуется, во-первых, динамика по
    подмножествам, во-вторых, умение по объекту находить номер. Обратите
    внимание, что ДП по подмножествам потребует тут ещё одного параметра,
    кроме самого подмножества, но зато обойдётся без этих мучений с поиском
    какого-нибудь элемента множества.
    |
    Подзадачей у нас будет «сколько
    существует :math:`k`-перестановок на множестве :math:`i`, начинающихся
    на число №\ :math:`j`\ », т.е. параметры динамики — :math:`i` и
    :math:`j`. Дальше, я думаю, идеологически все просто, но технически надо
    повозиться.
    
    Во-первых, конечно, надо будет отсортировать те числа, которые вам даны.
    Во-вторых, тут будет нетривиальная инициализация динамики — я не смог
    придумать, как бы обойтись инициализацией только пустого множества,
    приходится в качестве «базы динамики» рассматривать все множества
    размера 1. В-третьих, удобно будет ввести ещё одно число, которое может
    соседствовать с любым данным числом, чтобы для получения общего
    количества :math:`k`-перестановок не суммировать в отдельном цикле
    :math:`ans[i,j]` по всем :math:`j`, а сразу получить ответ в
    соответствующем элементе :math:`ans` (если сейчас не понятно, то пока
    забейте, потом посмотрите решение).
    |
    Итак, написал я эту задачу и
    даже протестил на всех тестах. Действительно, нетривиально. Привожу код.
    
    ::
    
        {$r+,q+,s+,i+,o+}
        {$apptype console}
        uses sysutils;
        var n,gcdmin:integer;
            reqn:int64;
            a:array[0..16] of integer;
            can:array[0..16,0..16] of integer;
            ans:array[0..1 shl 17-1,0..16] of int64;
            f:text;
            ii,i,j,k:integer;
            t:integer;
    
        function gcd(a,b:integer):integer;
        begin
        if b=0 then
           gcd:=a
        else gcd:=gcd(b,a mod b);
        end;
    
        procedure out(i,j:integer;reqn:int64);
        var k,ii:integer;
        begin
        ii:=i and (not (1 shl j));
        for k:=0 to n do if (i and (1 shl k)<>0)
                  and(k<>j)and(can[j,k]=1) then begin
            if ans[ii,k]>=reqn then begin
               write(f,a[k],' ');
               out(ii,k,reqn);
               exit;
            end;
            reqn:=reqn-ans[ii,k];
        end;
        end;
    
        begin
        assign(f,'perm.in');reset(f);
        read(f,n,reqn,gcdmin);
        a[0]:=0;
        for i:=1 to n do
            read(f,a[i]);
        close(f);
        for i:=n-1 downto 1 do
            for j:=1 to i do
                if a[j]>a[j+1] then begin
                   t:=a[j];a[j]:=a[j+1];a[j+1]:=t;
                end;
        for i:=1 to n do
            for j:=1 to n do
                if gcd(a[i],a[j])>=gcdmin then
                   can[i,j]:=1
                else can[i,j]:=0;
        for i:=0 to n do begin
            can[0,i]:=1;
            can[i,0]:=1;
        end;
        for i:=2 to 1 shl (n+1)-1 do
            for j:=0 to n do if i and (1 shl j)<>0 then begin
                ii:=i and (not (1 shl j));
                if ii=0 then begin
                   ans[i,j]:=1;
                   continue;
                end;
                ans[i,j]:=0;
                for k:=0 to n do if (i and (1 shl k)<>0)
                        and(can[j,k]=1)and(j<>k) then
                    inc(ans[i,j],ans[ii,k]);
            end;
        assign(f,'perm.out');rewrite(f);
        if ans[1 shl (n+1)-1,0]<reqn then
           writeln(f,-1)
        else out(1 shl (n+1)-1,0,reqn);
        close(f);
        end.
    
    Комментарии. Функция :math:`gcd` считает НОД двух чисел по алгоритму
    Евклида; надеюсь, вы это знаете. Если вы пиите длиннее, то обратите
    внимание, что это можно писать так коротко.
    
    Функцию :math:`out` прокомментирую ниже, пока комментарии к основной
    проге. Завожу число №0 — то самое дополнительное число. Считываю числа и
    сортирую их (сортирую пузырьком, т.к. все равно их мало). Насчитываю
    матрицу :math:`can`: :math:`can[i,j]=1`, если :math:`j` может идти после
    :math:`i`. Нулевое число может идти после любого и перед любым, на это
    нужен отдельный цикл. Дальше основной цикл динамики. Для каждого
    множества :math:`i` и каждого :math:`j` нахожу число
    :math:`k`-перестановок множества :math:`i`, начинающихся на число
    №\ :math:`j`. Ясно, что надо перебрать, какое число будет идти после
    :math:`j` — пусть :math:`k`, и если оно действительно может идти (т.е.
    :math:`can[j,k]=1`), то добавить к :math:`ans[i,j]` ответ на подзадачу с
    множеством, получающимся из :math:`i` выкидыванием числа :math:`j` (т.е.
    ``ii=i and (not (1 shl j))``, и этот номер не зависит от
    не зависит от :math:`k`) и первым числом :math:`k` — т.е. к
    :math:`ans[i,j]` добавляем :math:`ans[ii,k]`. Особо обрабатываем случай,
    когда в :math:`i` содержится только одно число — т.е. :math:`ii=0`. Это
    — база динамики, поэтому отдельно присваиваем :math:`ans[i,j]:=1`.
    
    Далее выводим решение. Обратите внимание, что, за счёт введения нулевого
    числа ответ у нас сразу хранится в ``ans[1 shl (n+1)-1, 0]`` (а
    (а иначе пришлось бы суммировать по всем возможным начальным числам).
    
    Функция :math:`out` стандартным образом выводит :math:`reqn`-ое решение
    (я везде на протяжении программы использую :math:`mingcd` вместо того,
    что в условии называется :math:`k`, и :math:`reqn` вместо :math:`m`).
    Обратите внимание: это как раз тот случай, на который я не давал примера
    в основном тексте: когда вариантов много и надо перебрать их все в
    цикле. Казалось бы, что можно :math:`j` выводить сразу на входе в
    процедуру :math:`out`, но я его вывожу в цикле, что позволяет не
    выводить нулевое число. Ещё обратите внимание, что база динамики тут
    обрабатывается основным кодом.
    
    Ещё обратите внимание, что числа, считанные из входного файла, я нумерую
    с единицы. Обычно в задачах на динамику по подмножествам приходится
    нумеровать с нуля, чтобы битовая арифметика работала, но тут у меня есть
    особое нулевое число, и потому остальные элементы нумерую с единицы.
    
    Наконец, как до этого всего догадаться? Ну, имея некоторый навык,
    несложно сразу понять. Но можно догадаться через перебор. Как бы мы
    стали писать перебор? Стали бы выбирать, какое число поставить следующим
    и запускались бы рекурсивно (подумайте!). Давайте попробуем это
    превратить в рекурсию с запоминанием результата. Для этого надо, чтобы
    наша функция всегда возвращала одно и то же при одних и тех же
    параметрах — т.е. давайте поймём, какие параметры ей нужны. Несложно
    видеть, что, во-первых, надо одним из параметров сделать множество
    оставшихся чисел, т.к. при каждом запуске нашей переборной функции это
    множество может быть новым, и от него сильно зависит результат.
    Во-вторых, наше решение о том, какое число можно ставить следующим,
    сильно зависит от того, какое число мы только что поставили,
    соответственно, от этого зависит и ответ. После этого ясно, что больше
    результат нашей функции ни от чего не зависит — поэтому можно делать
    запоминание результата, т.е. динамику.
    |

ДП по профилю
-------------

Считается, видимо, самой страшной темой, хотя, как во всей динамике,
ничего страшного тут, если разобраться и прочувствовать. Идея обычно
такая: пусть имеется поле размера :math:`N\times M`, при этом :math:`N`
может быть велико, зато :math:`M` обычно очень мало. Надо с этим полем
что-то сделать: покрасить, расставить на нем королей и т.п. ДП по
профилю состоит в следующем: назовём *профилем* решение или т.п.
(раскраску, расстановку королей и т.п.) для поля :math:`1\times M` [в
более сложных задачах может потребоваться поле :math:`2\times M` и т.п.,
и профиль будет не обязательно решение, а что-то ещё… В общем, в общем
случае надо думать головой :), но основная идея от этого не изменится] 

И теперь основная идея: за счёт того, что :math:`M` невелико, всевозможных
профилей будет не слишком много, а потому мы сможем сделать следующее.
Для каждого :math:`i` и для каждого профиля :math:`p` решим нашу задачу
для поля :math:`i\times M` при условии, что последняя строка решения
(раскраски, расстановки, …) будет совпадать с профилем :math:`p`. (Я
считаю, что размер поля — :math:`i` по вертикали, :math:`M` по
горизонтали и в этом смысле и говорю о строке. Можно было считать, что
:math:`i` по горизонтали, :math:`M` по вертикали, и требовать, чтобы
последний *столбец* совпадал с профилем :math:`p`.) В более сложных
задачах, конечно, может быть хитрее.

Но давайте лучше рассмотрим пример. Классическая задача на ДП по профилю
— `Симпатичные узоры <https://algoprog.ru/material/p587>`_. Рассмотрим клеточное поле :math:`N\times M`.
Раскрасим его клетки в белый и чёрный цвета. Назовём полученную
раскраску — узор — симпатичным, если нигде внутри него не встречается
однотонного квадрата :math:`2\times 2`. Т.е. в любом квадрате
:math:`2\times 2` хотя бы одна клетка белая и хотя бы одна клетка
чёрная. Даны :math:`N`, :math:`M`, требуется найти количество
симпатичных узоров размера :math:`N\times M`.

Будем считать, что :math:`M` невелико (очень невелико, так, что мы можем
позволить себе работать за :math:`O(N\cdot 4^M)` и можем позволить
выделить в памяти двумерный массив :math:`N\times 2^M`). Решим эту
задачу динамикой по профилю.

Профилем назовём раскраску в белый и чёрный цвета строки
:math:`1\times M`; всего разных профилей, очевидно, будет :math:`2^M`
(пока о симпатичности не говорим). Теперь, для каждого :math:`i`
(:math:`1\leq i \leq N`) и для каждого профиля :math:`p` решим следующую
задачу: определить количество симпатичных узоров размера
:math:`i\times M` при условии, что их последняя строка является профилем
:math:`p`. Точнее. Профили, конечно, будем нумеровать от 0 до
:math:`2^M-1`. Пусть :math:`ans[i,j]` есть количество симпатичных узоров
размера :math:`i\times M` таких, что их последняя строчка есть профиль с
номером :math:`j`. Как вычислять :math:`ans[i,j]`? Легко. При
:math:`i=1`, очевидно, :math:`ans[1,j]=1` для любого :math:`j`:
последняя и единственная строка строго фиксирована, о симпатичности речи
пока нет, т.к. все узоры размера :math:`1\times M` симпатичны: там
просто нет квадратов :math:`2\times 2`.

Пусть теперь :math:`i>1`. Попробуем свести задачу :math:`(i,j)` к
задачам с меньшим :math:`i`. Легко. Последняя строка нашего узора
фиксирована, а какой может быть предпоследняя строка? Ясно, что это тоже
будет некоторый профиль с номером :math:`k` такой, что в последних двух
строках нет однотонных квадратов :math:`2\times 2` (т.е. профиль
:math:`k` может идти перед профилем :math:`j` тогда и только тогда,
когда если пририсовать профиль :math:`j` под профилем :math:`k`, получив
прямоугольник :math:`2\times M`, то он будет симпатичным). Более того,
ясно, что если :math:`k` может идти перед :math:`j`, то узоров, в
которых последняя строка :math:`j`, а предпоследняя строка :math:`k`,
будет ровно :math:`ans[i-1,k]`. Ура!

.. math:: ans[i,j]=\sum_k ans[i-1,k],

сумма берётся по всем профилям :math:`k` таким, что профиль :math:`j`
может идти после профиля :math:`k`.

Ответом на задачу теперь будет просто сумма по всем профилям
:math:`ans[N,i]`:

.. math:: global\_ans=\sum_{i=0}^{2^M-1} ans[N,i].

Как и обещал, решение работает за :math:`O(N\cdot 2^M\cdot 2^M)` и
требует :math:`O(N\cdot 2^M)` памяти.

Эта задача была на первой Всероссийской олимпиаде школьников по
командному программированию в 2000 году. Мы её тогда решили с третьей попытки;
алгоритм, видимо, придумал Сергей Политов. Вот его реализация
(дословно то, что мы тогда сдавали на олимпиаде, с добавлением пометок
в комментариях):

::

    const inputFile='input.txt';
          OutputFile='output.txt';
    var
      a: array[0..31] of String;
      q, r: array[0..31] of Longint;
      t: array[0..31, 0..31] of Byte;
      n, m, c: Integer;
    function Bin(a: Byte): String;
    var
      s: String[6];
      i: Byte;
    begin
      i:= 1; s[0]:= #0;
      while i<1 shl n do
      begin
        if a and i=0 then s:= #48+s else s:= #49+s;
        Inc(i, i);
      end;
      Bin:= s;
    end;
    function Can(s1, s2: String): Byte;
    var
      i: Byte;
      l: Byte absolute s1;
    begin
      Can:= 0;
      for i:= 1 to l-1 do
        if(s1[i]=s1[i+1])and(s1[i]=s2[i])and(s1[i]=s2[i+1])
          then Exit;
      Can:= 1;
    end;
    procedure init;
    var
      i: Byte;
    begin
      assign(input,InputFile);reset(input);
      Readln(n, m); 
      if m<n then begin i:= m; m:= n; n:= i; end;
      close(input);
    end;
    procedure solve;
    var
      i, j, w: Byte;
      g: Integer;
    begin
      c:= 1 shl n;
      for i:= 0 to c-1 do a[i]:= Bin(i); { (1) }
      for i:= 0 to c-1 do                { (2) }
        for j:= i to c-1 do begin 
          w:= Can(a[i], a[j]); t[i, j]:= w; t[j, i]:= w; 
        end;
      for i:= 0 to c-1 do q[i]:= 1;
      for g:= 0 to m-2 do  { (3) }
      begin
        for i:= 0 to c-1 do  
        begin
          r[i]:= 0;
          for j:= 0 to c-1 do Inc(r[i], q[j]*t[i, j]); { (4) }
        end;
        q:= r;   { (5) }
      end;
    end;
    procedure print;
    var
      sm: Longint;
      i: Byte;
    begin
      assign(output,OutputFile);rewrite(output);
      sm:= 0; for i:= 0 to c-1 do Inc(sm, q[i]);
      Writeln(sm);
      close(output);
    end;
    begin
      init;
      solve;
      print;
    end.

Написано несколько своеобразно, но вполне хорошо и красиво. Обозначения
здесь другие, чем в моем изложении выше, в частности, :math:`N` и
:math:`M` поменяны местами (т.е. профилей теперь :math:`2^N` и т.д.).

Функция Bin переводит номер профиля в строку; функция Can определяет,
может ли один профиль идти за другим, и возвращает 1, если да, и 0, если
нет. Процедура solve содержит собственно алгоритм. Сначала (1)
насчитываем строки по профилям, потом (цикл (2)) насчитываем матрицу
:math:`t`: :math:`t[i,j]` равно единице, если профиль :math:`j` может
следовать за профилем :math:`i` (заметьте, что, очевидно,
:math:`t[i,j]=t[j,i]`). Ограничение было, видимо, :math:`M\leq 5`, и
потому все массивы до 31.

А далее… Собственно основной цикл ДП — цикл (3). Вы ещё не удивились,
что обещанного массива :math:`N\times 2^M` нет? Это то, о чем я говорил
в конце раздела :ref:`fundamental`: что нередко достаточно сохранять
не весь массив ответов, а лишь пару его последних строк. Здесь ответы
для текущей строки зависят лишь от ответов для предыдущей строки,
поэтому можно хранить лишь ответы для текущей и предыдущей строки (номер
текущей строки здесь равен, видимо, :math:`g+2`: :math:`g` идёт от 0 до
:math:`m-2`, а номер строки должен идти от :math:`2` до :math:`m`). В
:math:`q` хранится ответ для предыдущей строки: :math:`q[j]` равно
количеству симпатичных узоров размера :math:`M\times (g+1)` с профилем
:math:`j` в конце; — а в :math:`r` насчитывается ответ для текущей
строки: :math:`r[i]` есть количество симпатичных узоров размера
:math:`M\times (g+2)` с профилем :math:`i` в конце. В основном цикле (3)
для обработки очередной строки надо насчитать все :math:`r[i]`, для
этого цикл по :math:`i`. В нем делаем суммирование в соответствии с
нашей рекурсивной формулой — цикл (4). Обратите внимание, как
получается, что за счёт того, что :math:`t[i,j]` равно 1 или 0, мы либо
добавляем :math:`q[j]` к :math:`r[i]`, либо нет. После того, как
вычислили :math:`r[i]` для всех :math:`i`, переходим к следующему
:math:`g`, и надо выполнить q:=r (5).

Процедура print вычисляет окончательный ответ и выводит его.



.. task::

    Научитесь выводить симпатичный узор по номеру. Т.е.
    придумайте, в каком порядке симпатичные узоры можно занумеровать так,
    чтобы вы смогли по номеру вывести узор, и научитесь это делать.
    
    |
    |
    Я не буду тут писать никакого ответа, но постарайтесь все-таки
    что-нибудь придумать.
    |

Надеюсь, что идеей динамики по профилю вы прониклись.



.. task::

    Сколько есть способов расставить королей на доске
    :math:`N\times M` так, чтобы никто из них никого не бил? Не знаю, вдруг
    тут есть формула, но решите эту задачу динамикой по профилю. Тогда вы
    сможете решить и такую задачу: на доске :math:`N\times M` несколько
    клеток вырезаны. Сколькими способами на оставшихся клетках можно
    расставить королей, чтобы никто никого не бил?
    |
    |
    Ясно, что
    профилем тут будет расстановка королей в одной строке. Таким образом,
    профилей будет :math:`2^N`, легко определить, какой профиль может идти
    после какого и т.д. Код приводить не буду.
    |

Динамика по изломанному профилю
-------------------------------

Ну, это совсем высший пилотаж. Если вы что-то не поняли выше, то лучше
разберитесь в том, что там не поняли. Если же все понимаете и
прониклись, то рассматривайте этот раздел как материал к размышлению.

ДП по изломанному профилю позволяет, например, решить задачу про
симпатичные узоры за типа :math:`O(NM\cdot 2^M)`, т.е. теперь тут не
:math:`4^M`, а :math:`2^M`. Расписывать его вам тут не буду, кратко идея
вот в чем: для каждого :math:`i` и :math:`j` рассмотрим доску, имеющую
следующую форму: это прямоугольник :math:`(i+1)\times M`, из последней
(:math:`(i+1)`-ой) строки которой удалены правые :math:`M-j` клеток
(т.е. левые :math:`j` сохранены). Для каждого :math:`i`, :math:`j` и
:math:`p` определим количество симпатичных узоров для такой доски при
условии, что нижние клетки всех :math:`M` столбцов образую профиль
:math:`p` (т.е. профиль теперь частично в :math:`i`-ой строке, а
частично — в :math:`(i+1)`-ой). Задача в общем случае сводится к
:math:`(i,j-1,p')`, а при :math:`j=0` — к :math:`(i-1,M,p)`.

Если вы уже мастера ДП, то подумайте над тем, что я тут написал и,
наверное, вы сразу поймёте, в чем суть и даже, может быть, сможете
написать.

Динамика для выпуклых многоугольников
-------------------------------------

(Не путать с convex hull optimization, которая не рассматривается в этом тексте.)

Выпуклые многоугольники обладают рядом свойств, которые позволяют
применять динамику в разных задачах, так или иначе связанных с ними.
Основное свойство — что вершины выпуклого многоугольника можно отсортировать
по полярному углу относительно какой-нибудь точки, 
и тогда они будут идти как раз в порядке обхода вдоль многоугольника.

Далее, если из выпуклого многоугольника удалить вершину, то оставшиеся вершины тоже будут
образовывать выпуклый многоугольник, на этом можно строить сведение задачи к подзадачам.
В частности, можно формировать выпуклый многоугольник, набирая вершины из некоторого множества 
в порядке сортировки точек по полярному углу. Это в чем-то аналогично
алгоритмам построения выпуклой оболочки (Джарвиса и Грэхема).

Кроме того, зачастую бывает 
удобно взять самую нижнюю вершину многоугольника (если таких несколько — самую левую),
и отсортировать все остальные вершины и другие важные для задачи точки по полярному углу
относительно этой вершины. 

Дальше в разных задачах можно придумать
разные алгоритмы, так или иначе базирующиеся на этих идеях.

Я разберу тут одну задачу на эту тему, которая хорошо иллюстрирует основные приемы.

Задача `Орлы и дятлы <https://algoprog.ru/material/pe3001p2>`_.

    В лесу находятся гнезда орлов и дятлов. Когда у орлов вылупились птенцы, они решили огородить 
    «детскую площадку», на которой молодежь могла бы резвиться под надзором взрослых особей. 
    Орлы хотят, чтобы детская площадка имела максимально возможную площадь, и чтобы дополнительно выполнялись следующие условия:

    - площадка являлась выпуклым многоугольником, в вершинах которого находились гнезда орлов;
    - зная привычку дятлов все время долбить и опасаясь, что какой-нибудь дятел насмерть задолбает кого-нибудь 
      из еще неокрепших птенцов, орлы хотят, чтобы на территории площадки (а также на ее границе) не было гнезд дятлов.

    Напишите программу, которая по заданному расположению гнезд орлов и дятлов находит оптимальное место для строительства детской площадки.

    Количество гнезд орлов не превосходит 100, гнезд дятлов тоже не превосходит 100. Все происходит на плоскости
    (положения гнезд задаются парами координат :math:`(x, y)`).

Это задача с летних сборов кандидатов в сборную России 2003 года. Не помню, кто ее придумал, но насколько я помню, 
условие, тесты, чекер и авторское решение писал я :)

Решается она следующим образом. Рассмотрим какое-нибудь решение, т.е. какой-нибудь выпуклый многоугольник, соответствующий условиям задачи.
Возьмем в этом многоугольнике самую нижнюю точку, а если их несколько, то самую левую. Будем называть такую точку «левой нижней» точкой
многоугольника (хотя фраза «левая нижняя» не совсем точно описывает критерий выбора точки). Про остальные точки многоугольника
будем говорить, что они находятся «выше или правее» (хотя это тоже не совсем точная формулировка).

Естественно, заранее мы не знаем, какая точка (какое гнездо орла) должна быть левой нижней. Поэтому переберем все гнезда орлов,
и для каждого построим максимальный многоугольник, соответствующий условию, чтобы это выбранное гнездо было левым нижним.

Итак, зафиксировали левую нижнюю точку, пусть это точка :math:`O`. Дальше понятно, что точки, лежащие ниже этой точки, а также точки,
лежащие на той же горизонтальной прямой, но левее, не могу входить в искомый многоугольник по определению левой нижней точки.
Выкинем эти точки, а все оставшиеся (лежащие выше, а также лежащие на той же прямой, но правее) отсортируем по полярному углу относительно
точки :math:`O`.

.. note:: 
    Сортировка по полярному углу не требует использования вещественных чисел, достаточно использовать векторное произведение.
    В нашем случае компаратор для двух точек будет вообще очень простым: если надо сравнить две точки :math:`A` и :math:`B`,
    берем векторное произведение векторов :math:`\vec{OA}` и :math:`\vec{OB}`, и в зависимости от знака векторного произведения
    решаем, какая из точек «больше» в смысле сортировки.

    Обратите внимание, что это существенно опирается на то, что все наши точки лежат выше или правее :math:`O`. Если бы это было не так,
    то одного знака векторного произведения не было бы достаточно: можно было бы найти такие три точки :math:`A`, :math:`B`, :math:`C`,
    что точка :math:`A` «меньше» :math:`B`, а та в свою очередь меньше :math:`C`, а :math:`C` «меньше» :math:`A`, т.е. не будет выполняться
    транзитивность. Но в нашем случае все полярные углы лежат на полуинтервале :math:`[0°, 180°)`, поэтому проблем не будет.


Теперь у нас есть последовательность точек, и нам надо выбрать из этих точек некоторые, чтобы (вместе с точкой :math:`O`) 
получился выпуклый многоугольник, удовлетворяющий условию. И тут важное наблюдение — вершины нашего многоугольника будут идти
как раз в порядке сортировки по полярному углу, т.е. это уже становится похоже на какие-то задачи на динамику: есть последовательность
точек, надо выбрать подпоследовательность так, чтобы выполнялись определенные условия, с определенным критерием оптимизации.

.. figure:: eagles/fig1.png
    :width: 40%
    :align: center

    Пример: кружочками отмечены гнезда орлов, гнезда дятлов не показаны. В центре дополнительно обведена в кружок текущая выбранная точка :math:`O`.
    Закрашенные кружки — точки, которые могут входить в текущее решение (с текущей точкой :math:`O`). Незакрашенные кружки — точки, 
    которые не могут входить в текущее решение. Стрелка указывает порядок сортировки (по полярному углу относительно точки :math:`O`),
    а также, вместе с ломаной, иллюстрирует процесс формирования искомого многоугольника (подробнее далее).

По общим принципам динамики, *давайте будем решать подзадачи*. Как обычно, первая идея — давайте возмем первые :math:`i` точек в нашем порядке
и попробуем решить задачу для них. Тут как обычно надо подумать, требуем мы, чтобы точка :math:`i` обязательно входила в решение
или нет, стоит обдумать оба варианта, в этой задаче решение построится, если мы потребуем, чтобы точка :math:`i` *входила*.

Итак, попробуем: :math:`dp[i]` — это максимальная площадь выпуклого многоугольника, построенного с использованием только первых :math:`i`
точек (в нашем порядке сортировки), так, чтобы точка :math:`i` входила, ну и точки :math:`O`.

В соответствии со вторым общим принципом динамики, *посмотрим, на что может заканчиваться решение*. Ну, заканчивается оно на точку :math:`i`,
что тогда должно идти перед ней? Пусть какая-то точка :math:`j`, при этом, естественно, :math:`j<i` (т.е. точка :math:`j` идет в нашем порядке
сортировки раньше :math:`i`). Мы уже знаем ответ :math:`dp[j]`, давайте подумаем, можно ли его применить для :math:`dp[i]`?
У нас есть два требования: что многоугольник должен быть выпуклым, и что внутри многоугольника не должно быть гнезд дятлов.

Второе требование выполняется легко: получающийся у нас многоугольник состоит из ответа для подзадачи :math:`j`, плюс треугольник :math:`OA_jA_i`.
В ответе для подзадачи :math:`j` дятлов нет; есть ли дятлы в :math:`OA_iA_j`, несложно проверить, перебрав всех дятлов.

Но вот с требованием выпуклости получается сложно. Ответ на подзадачу :math:`j`, очевидно, выпуклый, но останется ли он выпуклым после того,
как мы к нему добавим точку :math:`i`? Очевидно, не всегда, это зависит от того, получится в вершине :math:`j` угол больше 180° или нет.
А это в свою очередь зависит от того, какая вершина идет перед :math:`j` в ответе для :math:`dp[j]`, а этого мы не знаем...

Говоря по-другому, не выполняется принцип оптимальности для подзадач: если мы выкинем вершину :math:`i` из решения задачи :math:`dp[i]`,
то, конечно, у нас получится решение подзадачи :math:`dp[j]`, т.е. многоугольник, заканчивающийся в :math:`j`, но это не обязательно
будет оптимальный многоугольник, потому что, возможно, к оптимальному решению :math:`dp[j]` нельзя добавить :math:`i`, нарушится
условие выпуклости.

.. figure:: eagles/fig2.png
    :width: 80%
    :align: center

    Пример: Две возможные ситуации, описанные выше. Здесь уже показаны только интересные нам точки (которые выше или правее точки :math:`O`).
    Мы решаем задачу :math:`dp[i]`: пытаемся построить решение на первых :math:`i` точках (идущих в порядке сортировки до точки :math:`i`),
    используя решение для задачи :math:`dp[j]`. Решение для задачи :math:`dp[j]` показано темно-серым многоугольником, мы по факту достраиваем 
    к нему светло-серый треугольник. Проверка наличия дятлов делается легко: в темно-серой области их не может быть (иначе это не решение
    для :math:`dp[j]`), а в светло-серой несложно проверить. А вот проверка выпуклости не получается: на рисунке слева многоугольник получается
    выпуклым, справа — невыпуклым. Поскольку мы не знаем, какой из двух вариантов имел место для :math:`dp[j]`, то мы не можем быть уверены,
    что мы можем из решения для :math:`dp[j]` сделать решение для :math:`dp[i]`.


Но, в общем-то, это довольно стандартная ситуация для ДП. Если нам нужно что-то знать про решение подзадач, то надо это сделать параметром подзадачи!
Если нам нужно знать, какая вершина идет перед :math:`j` в решении для :math:`dp[j]`, то давайте рассмотрим другие подзадачи:
:math:`dp[j][k]` будет максимальной площадью многоугольника, который заканчивается вершиной :math:`j`, 
а предпоследней вершиной является вершина :math:`k`!

Итак, тогда, возвращаясь на несколько абзацев назад, мы решаем уже не задачу :math:`dp[i]`, а задачу :math:`dp[i][j]` — ищем максимальный
многоугольник, который заканчивается на вершину :math:`i`, а перед ней идет :math:`j`. Опять-таки, смотрим, на что заканчивается решение?
Ну понятно, что на :math:`i`, перед ней идет :math:`j`, а перед ней пусть идет точка :math:`k`. Соответственно, смотрим, можно ли
из решения :math:`dp[j][k]` получить вариант для :math:`dp[i][j]`? А это уже несложно проверить: просто надо, чтобы при переходе от :math:`A_k`
к :math:`A_j` и далее к :math:`A_i` мы поворачивали бы в нужную сторону (влево). Очень напоминает алгоритмы выпуклой оболочки, если вы их знаете.
Это проверяется, естественно, векторным произведением. 

И вот тут уже принцип оптимальности для подзадач выполняется: если мы поворачиваем от :math:`A_k`
к :math:`A_j` и далее к :math:`A_i` в нужную сторону, то *к любому решению* задачи :math:`dp[j][k]` можно добавить точку :math:`i`,
и получить решение для :math:`dp[i][j]`. Соответственно, и наилучшее из таких решений получается
из наилучшего решения задачи :math:`dp[j][k]`. А если не в нужную сторону, то в принципе вариантов решения с тройкой :math:`(i, j, k)` нет,
и рассматривать такое :math:`k` не обязательно.

Ну и не забыть про проверку дятлов: в решении подзадачи для :math:`dp[j][k]` дятлов точно нет, осталось проверить, чо дятлов нет в треугольнике 
:math:`OA_jA_i`. Если они там есть, то у подзадачи :math:`dp[i][j]` вообще нет решений.

.. figure:: eagles/fig3.png
    :width: 80%
    :align: center

    Пример: Конфигурация, аналогичная рисунку выше, то теперь мы уже
    решаем задачу :math:`dp[i][j]`: пытаемся построить решение на первых :math:`i` точках (идущих в порядке сортировки до точки :math:`i`),
    так, чтобы оно заканчивалось на точки :math:`i` и :math:`j`, 
    используя решение для задачи :math:`dp[j][k]`. Но теперь две рассмотренные выше ситуации соответствуют *разным* подзадачам, разным :math:`k`.
    Соответственно, для того :math:`k`, которое показано на рисунке слева, мы можем из задачи :math:`dp[j][k]` сделать решение задачи :math:`dp[i][j]`,
    добавив точку :math:`i`, а для того :math:`k`, которое показано на рисунке справа, не можем.


Итак, получаем алгоритм вычисления :math:`dp[i][j]`: во-первых, проверить, нет ли дятлов в треугольнике :math:`OA_iA_j`, 
если они там есть, то задача :math:`dp[i][j]` вообще не имеет решений. Иначе надо перебрать все :math:`k`, меньшие :math:`j`, 
проверить, что точки :math:`A_k`, :math:`A_j`, :math:`A_i` образуют угол в нужную сторону, и из всех таких :math:`k` выбрать такое,
чтобы максимизировать площадь получаемого многоугольника (:math:`dp[j][k] + S_{OAiAj}`, где второе слагаемое — 
площадь треугольника :math:`OA_iA_j`, она вообще даже не зависит от :math:`k`, поэтому достаточно взять максимальное :math:`dp[j][k]`,
и потом уже прибавить площадь треугольника). Осталось, конечно, учесть начальные значения динамики, это можно сделать различными
способами, например, считать, что для каждой точки в качестве предыдущей можно взять точку :math:`O`.

Итоговая сложность вычисления ответа на одну подзадачу — :math:`O(n)`, где :math:`n` — общее число точек (орлов и дятлов). Таких подзадач
у нас :math:`n^2`, поэтому общее вычисление матрицы :math:`dp` работает за :math:`O(n^3)`. Ну и не забудем, что мы перебираем
левую нижнюю точку и для каждой левой нижней точки гоняем ДП заново, таким образом, итоговая сложность :math:`O(n^4)`.

Вот мое авторское решение этой задачи со сборов 2003 (с комментариями, написанными в процессе написания этого текста):

.. include:: eagles/eagles.pas
    :code: pascal


.. [1]
   Почему подпоследовательность? Потому что подстрока — это когда все
   оставленные символы обязательно идут подряд, а в
   подпоследовательности не обязательно. Например у ``abcd``
   подпоследовательностями будут, например, ``ac`` и ``bc``, но лишь
   вторая из них — подстрокой.
